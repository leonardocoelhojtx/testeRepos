import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, QueryList, TemplateRef, AfterViewInit } from '@angular/core';
import { NgbCarouselConfig } from './carousel-config';
import { NgbSlideEventDirection } from './carousel-transition';
/**
 * A directive that wraps the individual carousel slide.
 */
import * as ɵngcc0 from '@angular/core';
export declare class NgbSlide {
    tplRef: TemplateRef<any>;
    /**
     * Slide id that must be unique for the entire document.
     *
     * If not provided, will be generated in the `ngb-slide-xx` format.
     */
    id: string;
    /**
     * An event emitted when the slide transition is finished
     *
     * @since 8.0.0
     */
    slid: EventEmitter<NgbSingleSlideEvent>;
    constructor(tplRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbSlide>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbSlide, "ng-template[ngbSlide]", never, {
    "id": "id";
}, {
    "slid": "slid";
}, never>;
}
/**
 * Carousel is a component to easily create and control slideshows.
 *
 * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
 */
export declare class NgbCarousel implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy {
    private _platformId;
    private _ngZone;
    private _cd;
    private _container;
    slides: QueryList<NgbSlide>;
    NgbSlideEventSource: typeof NgbSlideEventSource;
    private _destroy$;
    private _interval$;
    private _mouseHover$;
    private _focused$;
    private _pauseOnHover$;
    private _pauseOnFocus$;
    private _pause$;
    private _wrap$;
    /**
     * A flag to enable/disable the animations.
     *
     * @since 8.0.0
     */
    animation: boolean;
    /**
     * The slide id that should be displayed **initially**.
     *
     * For subsequent interactions use methods `select()`, `next()`, etc. and the `(slide)` output.
     */
    activeId: string;
    /**
     * Time in milliseconds before the next slide is shown.
     */
    set interval(value: number);
    get interval(): number;
    /**
     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
     */
    set wrap(value: boolean);
    get wrap(): boolean;
    /**
     * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.
     */
    keyboard: boolean;
    /**
     * If `true`, will pause slide switching when mouse cursor hovers the slide.
     *
     * @since 2.2.0
     */
    set pauseOnHover(value: boolean);
    get pauseOnHover(): boolean;
    /**
     * If `true`, will pause slide switching when the focus is inside the carousel.
     */
    set pauseOnFocus(value: boolean);
    get pauseOnFocus(): boolean;
    /**
     * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.
     *
     * @since 2.2.0
     */
    showNavigationArrows: boolean;
    /**
     * If `true`, navigation indicators at the bottom of the slide will be visible.
     *
     * @since 2.2.0
     */
    showNavigationIndicators: boolean;
    /**
     * An event emitted just before the slide transition starts.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     */
    slide: EventEmitter<NgbSlideEvent>;
    /**
     * An event emitted right after the slide transition is completed.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     *
     * @since 8.0.0
     */
    slid: EventEmitter<NgbSlideEvent>;
    private _transitionIds;
    set mouseHover(value: boolean);
    get mouseHover(): boolean;
    set focused(value: boolean);
    get focused(): boolean;
    constructor(config: NgbCarouselConfig, _platformId: any, _ngZone: NgZone, _cd: ChangeDetectorRef, _container: ElementRef);
    arrowLeft(): void;
    arrowRight(): void;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Navigates to a slide with the specified identifier.
     */
    select(slideId: string, source?: NgbSlideEventSource): void;
    /**
     * Navigates to the previous slide.
     */
    prev(source?: NgbSlideEventSource): void;
    /**
     * Navigates to the next slide.
     */
    next(source?: NgbSlideEventSource): void;
    /**
     * Pauses cycling through the slides.
     */
    pause(): void;
    /**
     * Restarts cycling through the slides from left to right.
     */
    cycle(): void;
    /**
     * Set the focus on the carousel.
     */
    focus(): void;
    private _cycleToSelected;
    private _getSlideEventDirection;
    private _getSlideById;
    private _getSlideIdxById;
    private _getNextSlide;
    private _getPrevSlide;
    private _getSlideElement;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbCarousel>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbCarousel, "ngb-carousel", ["ngbCarousel"], {
    "animation": "animation";
    "interval": "interval";
    "wrap": "wrap";
    "keyboard": "keyboard";
    "pauseOnHover": "pauseOnHover";
    "pauseOnFocus": "pauseOnFocus";
    "showNavigationArrows": "showNavigationArrows";
    "showNavigationIndicators": "showNavigationIndicators";
    "activeId": "activeId";
}, {
    "slide": "slide";
    "slid": "slid";
}, ["slides"]>;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 */
export interface NgbSlideEvent {
    /**
     * The previous slide id.
     */
    prev: string;
    /**
     * The current slide id.
     */
    current: string;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
    /**
     * Whether the pause() method was called (and no cycle() call was done afterwards).
     *
     * @since 5.1.0
     */
    paused: boolean;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     * @since 5.1.0
     */
    source?: NgbSlideEventSource;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 *
 * @since 8.0.0
 */
export interface NgbSingleSlideEvent {
    /**
     * true if the slide is shown, false otherwise
     */
    isShown: boolean;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     */
    source?: NgbSlideEventSource;
}
export declare enum NgbSlideEventSource {
    TIMER = "timer",
    ARROW_LEFT = "arrowLeft",
    ARROW_RIGHT = "arrowRight",
    INDICATOR = "indicator"
}
export declare const NGB_CAROUSEL_DIRECTIVES: (typeof NgbSlide | typeof NgbCarousel)[];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuZC50cyIsInNvdXJjZXMiOlsiY2Fyb3VzZWwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnSUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRDaGVja2VkLCBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdiQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuL2Nhcm91c2VsLWNvbmZpZyc7XG5pbXBvcnQgeyBOZ2JTbGlkZUV2ZW50RGlyZWN0aW9uIH0gZnJvbSAnLi9jYXJvdXNlbC10cmFuc2l0aW9uJztcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCB3cmFwcyB0aGUgaW5kaXZpZHVhbCBjYXJvdXNlbCBzbGlkZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdiU2xpZGUge1xuICAgIHRwbFJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBTbGlkZSBpZCB0aGF0IG11c3QgYmUgdW5pcXVlIGZvciB0aGUgZW50aXJlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB3aWxsIGJlIGdlbmVyYXRlZCBpbiB0aGUgYG5nYi1zbGlkZS14eGAgZm9ybWF0LlxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkXG4gICAgICpcbiAgICAgKiBAc2luY2UgOC4wLjBcbiAgICAgKi9cbiAgICBzbGlkOiBFdmVudEVtaXR0ZXI8TmdiU2luZ2xlU2xpZGVFdmVudD47XG4gICAgY29uc3RydWN0b3IodHBsUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KTtcbn1cbi8qKlxuICogQ2Fyb3VzZWwgaXMgYSBjb21wb25lbnQgdG8gZWFzaWx5IGNyZWF0ZSBhbmQgY29udHJvbCBzbGlkZXNob3dzLlxuICpcbiAqIEFsbG93cyB0byBzZXQgaW50ZXJ2YWxzLCBjaGFuZ2UgdGhlIHdheSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzbGlkZXMgYW5kIHByb3ZpZGVzIGEgcHJvZ3JhbW1hdGljIEFQSS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdiQ2Fyb3VzZWwgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRDaGVja2VkLCBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX3BsYXRmb3JtSWQ7XG4gICAgcHJpdmF0ZSBfbmdab25lO1xuICAgIHByaXZhdGUgX2NkO1xuICAgIHByaXZhdGUgX2NvbnRhaW5lcjtcbiAgICBzbGlkZXM6IFF1ZXJ5TGlzdDxOZ2JTbGlkZT47XG4gICAgTmdiU2xpZGVFdmVudFNvdXJjZTogdHlwZW9mIE5nYlNsaWRlRXZlbnRTb3VyY2U7XG4gICAgcHJpdmF0ZSBfZGVzdHJveSQ7XG4gICAgcHJpdmF0ZSBfaW50ZXJ2YWwkO1xuICAgIHByaXZhdGUgX21vdXNlSG92ZXIkO1xuICAgIHByaXZhdGUgX2ZvY3VzZWQkO1xuICAgIHByaXZhdGUgX3BhdXNlT25Ib3ZlciQ7XG4gICAgcHJpdmF0ZSBfcGF1c2VPbkZvY3VzJDtcbiAgICBwcml2YXRlIF9wYXVzZSQ7XG4gICAgcHJpdmF0ZSBfd3JhcCQ7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZS9kaXNhYmxlIHRoZSBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHNpbmNlIDguMC4wXG4gICAgICovXG4gICAgYW5pbWF0aW9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBzbGlkZSBpZCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgKippbml0aWFsbHkqKi5cbiAgICAgKlxuICAgICAqIEZvciBzdWJzZXF1ZW50IGludGVyYWN0aW9ucyB1c2UgbWV0aG9kcyBgc2VsZWN0KClgLCBgbmV4dCgpYCwgZXRjLiBhbmQgdGhlIGAoc2xpZGUpYCBvdXRwdXQuXG4gICAgICovXG4gICAgYWN0aXZlSWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIG5leHQgc2xpZGUgaXMgc2hvd24uXG4gICAgICovXG4gICAgc2V0IGludGVydmFsKHZhbHVlOiBudW1iZXIpO1xuICAgIGdldCBpbnRlcnZhbCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB3aWxsICd3cmFwJyB0aGUgY2Fyb3VzZWwgYnkgc3dpdGNoaW5nIGZyb20gdGhlIGxhc3Qgc2xpZGUgYmFjayB0byB0aGUgZmlyc3QuXG4gICAgICovXG4gICAgc2V0IHdyYXAodmFsdWU6IGJvb2xlYW4pO1xuICAgIGdldCB3cmFwKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBhbGxvd3MgdG8gaW50ZXJhY3Qgd2l0aCBjYXJvdXNlbCB1c2luZyBrZXlib2FyZCAnYXJyb3cgbGVmdCcgYW5kICdhcnJvdyByaWdodCcuXG4gICAgICovXG4gICAga2V5Ym9hcmQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB3aWxsIHBhdXNlIHNsaWRlIHN3aXRjaGluZyB3aGVuIG1vdXNlIGN1cnNvciBob3ZlcnMgdGhlIHNsaWRlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDIuMi4wXG4gICAgICovXG4gICAgc2V0IHBhdXNlT25Ib3Zlcih2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IHBhdXNlT25Ib3ZlcigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgd2lsbCBwYXVzZSBzbGlkZSBzd2l0Y2hpbmcgd2hlbiB0aGUgZm9jdXMgaXMgaW5zaWRlIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBzZXQgcGF1c2VPbkZvY3VzKHZhbHVlOiBib29sZWFuKTtcbiAgICBnZXQgcGF1c2VPbkZvY3VzKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCAncHJldmlvdXMnIGFuZCAnbmV4dCcgbmF2aWdhdGlvbiBhcnJvd3Mgd2lsbCBiZSB2aXNpYmxlIG9uIHRoZSBzbGlkZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjIuMFxuICAgICAqL1xuICAgIHNob3dOYXZpZ2F0aW9uQXJyb3dzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgbmF2aWdhdGlvbiBpbmRpY2F0b3JzIGF0IHRoZSBib3R0b20gb2YgdGhlIHNsaWRlIHdpbGwgYmUgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjIuMFxuICAgICAqL1xuICAgIHNob3dOYXZpZ2F0aW9uSW5kaWNhdG9yczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBlbWl0dGVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkZSB0cmFuc2l0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIFNlZSBbYE5nYlNsaWRlRXZlbnRgXSgjL2NvbXBvbmVudHMvY2Fyb3VzZWwvYXBpI05nYlNsaWRlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXG4gICAgICovXG4gICAgc2xpZGU6IEV2ZW50RW1pdHRlcjxOZ2JTbGlkZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBlbWl0dGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIFNlZSBbYE5nYlNsaWRlRXZlbnRgXSgjL2NvbXBvbmVudHMvY2Fyb3VzZWwvYXBpI05nYlNsaWRlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgOC4wLjBcbiAgICAgKi9cbiAgICBzbGlkOiBFdmVudEVtaXR0ZXI8TmdiU2xpZGVFdmVudD47XG4gICAgcHJpdmF0ZSBfdHJhbnNpdGlvbklkcztcbiAgICBzZXQgbW91c2VIb3Zlcih2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IG1vdXNlSG92ZXIoKTogYm9vbGVhbjtcbiAgICBzZXQgZm9jdXNlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IGZvY3VzZWQoKTogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IE5nYkNhcm91c2VsQ29uZmlnLCBfcGxhdGZvcm1JZDogYW55LCBfbmdab25lOiBOZ1pvbmUsIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9jb250YWluZXI6IEVsZW1lbnRSZWYpO1xuICAgIGFycm93TGVmdCgpOiB2b2lkO1xuICAgIGFycm93UmlnaHQoKTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZDtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0byBhIHNsaWRlIHdpdGggdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyLlxuICAgICAqL1xuICAgIHNlbGVjdChzbGlkZUlkOiBzdHJpbmcsIHNvdXJjZT86IE5nYlNsaWRlRXZlbnRTb3VyY2UpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0byB0aGUgcHJldmlvdXMgc2xpZGUuXG4gICAgICovXG4gICAgcHJldihzb3VyY2U/OiBOZ2JTbGlkZUV2ZW50U291cmNlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIG5leHQgc2xpZGUuXG4gICAgICovXG4gICAgbmV4dChzb3VyY2U/OiBOZ2JTbGlkZUV2ZW50U291cmNlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBQYXVzZXMgY3ljbGluZyB0aHJvdWdoIHRoZSBzbGlkZXMuXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0cyBjeWNsaW5nIHRocm91Z2ggdGhlIHNsaWRlcyBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICovXG4gICAgY3ljbGUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvY3VzIG9uIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIHByaXZhdGUgX2N5Y2xlVG9TZWxlY3RlZDtcbiAgICBwcml2YXRlIF9nZXRTbGlkZUV2ZW50RGlyZWN0aW9uO1xuICAgIHByaXZhdGUgX2dldFNsaWRlQnlJZDtcbiAgICBwcml2YXRlIF9nZXRTbGlkZUlkeEJ5SWQ7XG4gICAgcHJpdmF0ZSBfZ2V0TmV4dFNsaWRlO1xuICAgIHByaXZhdGUgX2dldFByZXZTbGlkZTtcbiAgICBwcml2YXRlIF9nZXRTbGlkZUVsZW1lbnQ7XG59XG4vKipcbiAqIEEgc2xpZGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5nYlNsaWRlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBzbGlkZSBpZC5cbiAgICAgKi9cbiAgICBwcmV2OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2xpZGUgaWQuXG4gICAgICovXG4gICAgY3VycmVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzbGlkZSBldmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAnbGVmdCcgfCAncmlnaHQnYC5cbiAgICAgKi9cbiAgICBkaXJlY3Rpb246IE5nYlNsaWRlRXZlbnREaXJlY3Rpb247XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcGF1c2UoKSBtZXRob2Qgd2FzIGNhbGxlZCAoYW5kIG5vIGN5Y2xlKCkgY2FsbCB3YXMgZG9uZSBhZnRlcndhcmRzKS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA1LjEuMFxuICAgICAqL1xuICAgIHBhdXNlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTb3VyY2UgdHJpZ2dlcmluZyB0aGUgc2xpZGUgY2hhbmdlIGV2ZW50LlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RpbWVyJyB8ICdhcnJvd0xlZnQnIHwgJ2Fycm93UmlnaHQnIHwgJ2luZGljYXRvcidgXG4gICAgICpcbiAgICAgKiBAc2luY2UgNS4xLjBcbiAgICAgKi9cbiAgICBzb3VyY2U/OiBOZ2JTbGlkZUV2ZW50U291cmNlO1xufVxuLyoqXG4gKiBBIHNsaWRlIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAc2luY2UgOC4wLjBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ2JTaW5nbGVTbGlkZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzbGlkZSBpcyBzaG93biwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNTaG93bjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2xpZGUgZXZlbnQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2xlZnQnIHwgJ3JpZ2h0J2AuXG4gICAgICovXG4gICAgZGlyZWN0aW9uOiBOZ2JTbGlkZUV2ZW50RGlyZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIFNvdXJjZSB0cmlnZ2VyaW5nIHRoZSBzbGlkZSBjaGFuZ2UgZXZlbnQuXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndGltZXInIHwgJ2Fycm93TGVmdCcgfCAnYXJyb3dSaWdodCcgfCAnaW5kaWNhdG9yJ2BcbiAgICAgKlxuICAgICAqL1xuICAgIHNvdXJjZT86IE5nYlNsaWRlRXZlbnRTb3VyY2U7XG59XG5leHBvcnQgZGVjbGFyZSBlbnVtIE5nYlNsaWRlRXZlbnRTb3VyY2Uge1xuICAgIFRJTUVSID0gXCJ0aW1lclwiLFxuICAgIEFSUk9XX0xFRlQgPSBcImFycm93TGVmdFwiLFxuICAgIEFSUk9XX1JJR0hUID0gXCJhcnJvd1JpZ2h0XCIsXG4gICAgSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgTkdCX0NBUk9VU0VMX0RJUkVDVElWRVM6ICh0eXBlb2YgTmdiU2xpZGUgfCB0eXBlb2YgTmdiQ2Fyb3VzZWwpW107XG4iXX0=