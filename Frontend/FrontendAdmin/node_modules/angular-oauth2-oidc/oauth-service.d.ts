import { NgZone, OnDestroy } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, Subject, Subscription } from 'rxjs';
import { ValidationHandler, ValidationParams } from './token-validation/validation-handler';
import { UrlHelperService } from './url-helper.service';
import { OAuthEvent, OAuthSuccessEvent } from './events';
import { OAuthLogger, OAuthStorage, LoginOptions, ParsedIdToken, OidcDiscoveryDoc, TokenResponse, UserInfo } from './types';
import { AuthConfig } from './auth.config';
import { HashHandler } from './token-validation/hash-handler';
/**
 * Service for logging in and logging out with
 * OIDC and OAuth2. Supports implicit flow and
 * password flow.
 */
import * as ɵngcc0 from '@angular/core';
export declare class OAuthService extends AuthConfig implements OnDestroy {
    protected ngZone: NgZone;
    protected http: HttpClient;
    protected config: AuthConfig;
    protected urlHelper: UrlHelperService;
    protected logger: OAuthLogger;
    protected crypto: HashHandler;
    private document;
    /**
     * The ValidationHandler used to validate received
     * id_tokens.
     */
    tokenValidationHandler: ValidationHandler;
    /**
     * @internal
     * Deprecated:  use property events instead
     */
    discoveryDocumentLoaded: boolean;
    /**
     * @internal
     * Deprecated:  use property events instead
     */
    discoveryDocumentLoaded$: Observable<OidcDiscoveryDoc>;
    /**
     * Informs about events, like token_received or token_expires.
     * See the string enum EventType for a full list of event types.
     */
    events: Observable<OAuthEvent>;
    /**
     * The received (passed around) state, when logging
     * in with implicit flow.
     */
    state?: string;
    protected eventsSubject: Subject<OAuthEvent>;
    protected discoveryDocumentLoadedSubject: Subject<OidcDiscoveryDoc>;
    protected silentRefreshPostMessageEventListener: EventListener;
    protected grantTypesSupported: Array<string>;
    protected _storage: OAuthStorage;
    protected accessTokenTimeoutSubscription: Subscription;
    protected idTokenTimeoutSubscription: Subscription;
    protected tokenReceivedSubscription: Subscription;
    protected sessionCheckEventListener: EventListener;
    protected jwksUri: string;
    protected sessionCheckTimer: any;
    protected silentRefreshSubject: string;
    protected inImplicitFlow: boolean;
    protected saveNoncesInLocalStorage: boolean;
    constructor(ngZone: NgZone, http: HttpClient, storage: OAuthStorage, tokenValidationHandler: ValidationHandler, config: AuthConfig, urlHelper: UrlHelperService, logger: OAuthLogger, crypto: HashHandler, document: Document);
    /**
     * Use this method to configure the service
     * @param config the configuration
     */
    configure(config: AuthConfig): void;
    protected configChanged(): void;
    restartSessionChecksIfStillLoggedIn(): void;
    protected restartRefreshTimerIfStillLoggedIn(): void;
    protected setupSessionCheck(): void;
    /**
     * Will setup up silent refreshing for when the token is
     * about to expire. When the user is logged out via this.logOut method, the
     * silent refreshing will pause and not refresh the tokens until the user is
     * logged back in via receiving a new token.
     * @param params Additional parameter to pass
     * @param listenTo Setup automatic refresh of a specific token type
     */
    setupAutomaticSilentRefresh(params?: object, listenTo?: 'access_token' | 'id_token' | 'any', noPrompt?: boolean): void;
    protected refreshInternal(params: any, noPrompt: any): Promise<TokenResponse | OAuthEvent>;
    /**
     * Convenience method that first calls `loadDiscoveryDocument(...)` and
     * directly chains using the `then(...)` part of the promise to call
     * the `tryLogin(...)` method.
     *
     * @param options LoginOptions to pass through to `tryLogin(...)`
     */
    loadDiscoveryDocumentAndTryLogin(options?: LoginOptions): Promise<boolean>;
    /**
     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`
     * and if then chains to `initLoginFlow()`, but only if there is no valid
     * IdToken or no valid AccessToken.
     *
     * @param options LoginOptions to pass through to `tryLogin(...)`
     */
    loadDiscoveryDocumentAndLogin(options?: LoginOptions & {
        state?: string;
    }): Promise<boolean>;
    protected debug(...args: any[]): void;
    protected validateUrlFromDiscoveryDocument(url: string): string[];
    protected validateUrlForHttps(url: string): boolean;
    protected assertUrlNotNullAndCorrectProtocol(url: string | undefined, description: string): void;
    protected validateUrlAgainstIssuer(url: string): boolean;
    protected setupRefreshTimer(): void;
    protected setupExpirationTimers(): void;
    protected setupAccessTokenTimer(): void;
    protected setupIdTokenTimer(): void;
    /**
     * Stops timers for automatic refresh.
     * To restart it, call setupAutomaticSilentRefresh again.
     */
    stopAutomaticRefresh(): void;
    protected clearAccessTokenTimer(): void;
    protected clearIdTokenTimer(): void;
    protected calcTimeout(storedAt: number, expiration: number): number;
    /**
     * DEPRECATED. Use a provider for OAuthStorage instead:
     *
     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }
     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }
     * Sets a custom storage used to store the received
     * tokens on client side. By default, the browser's
     * sessionStorage is used.
     * @ignore
     *
     * @param storage
     */
    setStorage(storage: OAuthStorage): void;
    /**
     * Loads the discovery document to configure most
     * properties of this service. The url of the discovery
     * document is infered from the issuer's url according
     * to the OpenId Connect spec. To use another url you
     * can pass it to to optional parameter fullUrl.
     *
     * @param fullUrl
     */
    loadDiscoveryDocument(fullUrl?: string): Promise<OAuthSuccessEvent>;
    protected loadJwks(): Promise<object>;
    protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean;
    /**
     * Uses password flow to exchange userName and password for an
     * access_token. After receiving the access_token, this method
     * uses it to query the userinfo endpoint in order to get information
     * about the user in question.
     *
     * When using this, make sure that the property oidc is set to false.
     * Otherwise stricter validations take place that make this operation
     * fail.
     *
     * @param userName
     * @param password
     * @param headers Optional additional http-headers.
     */
    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName: string, password: string, headers?: HttpHeaders): Promise<UserInfo>;
    /**
     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.
     *
     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.
     * Otherwise stricter validations take place that make this operation fail.
     */
    loadUserProfile(): Promise<UserInfo>;
    /**
     * Uses password flow to exchange userName and password for an access_token.
     * @param userName
     * @param password
     * @param headers Optional additional http-headers.
     */
    fetchTokenUsingPasswordFlow(userName: string, password: string, headers?: HttpHeaders): Promise<TokenResponse>;
    /**
     * Refreshes the token using a refresh_token.
     * This does not work for implicit flow, b/c
     * there is no refresh_token in this flow.
     * A solution for this is provided by the
     * method silentRefresh.
     */
    refreshToken(): Promise<TokenResponse>;
    protected removeSilentRefreshEventListener(): void;
    protected setupSilentRefreshEventListener(): void;
    /**
     * Performs a silent refresh for implicit flow.
     * Use this method to get new tokens when/before
     * the existing tokens expire.
     */
    silentRefresh(params?: object, noPrompt?: boolean): Promise<OAuthEvent>;
    /**
     * This method exists for backwards compatibility.
     * {@link OAuthService#initLoginFlowInPopup} handles both code
     * and implicit flows.
     */
    initImplicitFlowInPopup(options?: {
        height?: number;
        width?: number;
    }): Promise<unknown>;
    initLoginFlowInPopup(options?: {
        height?: number;
        width?: number;
    }): Promise<unknown>;
    protected calculatePopupFeatures(options: {
        height?: number;
        width?: number;
    }): string;
    protected processMessageEventMessage(e: MessageEvent): string;
    protected canPerformSessionCheck(): boolean;
    protected setupSessionCheckEventListener(): void;
    protected handleSessionUnchanged(): void;
    protected handleSessionChange(): void;
    protected waitForSilentRefreshAfterSessionChange(): void;
    protected handleSessionError(): void;
    protected removeSessionCheckEventListener(): void;
    protected initSessionCheck(): void;
    protected startSessionCheckTimer(): void;
    protected stopSessionCheckTimer(): void;
    checkSession(): void;
    protected createLoginUrl(state?: string, loginHint?: string, customRedirectUri?: string, noPrompt?: boolean, params?: object): Promise<string>;
    initImplicitFlowInternal(additionalState?: string, params?: string | object): void;
    /**
     * Starts the implicit flow and redirects to user to
     * the auth servers' login url.
     *
     * @param additionalState Optional state that is passed around.
     *  You'll find this state in the property `state` after `tryLogin` logged in the user.
     * @param params Hash with additional parameter. If it is a string, it is used for the
     *               parameter loginHint (for the sake of compatibility with former versions)
     */
    initImplicitFlow(additionalState?: string, params?: string | object): void;
    /**
     * Reset current implicit flow
     *
     * @description This method allows resetting the current implict flow in order to be initialized again.
     */
    resetImplicitFlow(): void;
    protected callOnTokenReceivedIfExists(options: LoginOptions): void;
    protected storeAccessTokenResponse(accessToken: string, refreshToken: string, expiresIn: number, grantedScopes: String, customParameters?: Map<string, string>): void;
    /**
     * Delegates to tryLoginImplicitFlow for the sake of competability
     * @param options Optional options.
     */
    tryLogin(options?: LoginOptions): Promise<boolean>;
    private parseQueryString;
    tryLoginCodeFlow(options?: LoginOptions): Promise<void>;
    /**
     * Retrieve the returned auth code from the redirect uri that has been called.
     * If required also check hash, as we could use hash location strategy.
     */
    private getCodePartsFromUrl;
    /**
     * Get token using an intermediate code. Works for the Authorization Code flow.
     */
    private getTokenFromCode;
    private fetchAndProcessToken;
    /**
     * Checks whether there are tokens in the hash fragment
     * as a result of the implicit flow. These tokens are
     * parsed, validated and used to sign the user in to the
     * current client.
     *
     * @param options Optional options.
     */
    tryLoginImplicitFlow(options?: LoginOptions): Promise<boolean>;
    private parseState;
    protected validateNonce(nonceInState: string): boolean;
    protected storeIdToken(idToken: ParsedIdToken): void;
    protected storeSessionState(sessionState: string): void;
    protected getSessionState(): string;
    protected handleLoginError(options: LoginOptions, parts: object): void;
    /**
     * @ignore
     */
    processIdToken(idToken: string, accessToken: string, skipNonceCheck?: boolean): Promise<ParsedIdToken>;
    /**
     * Returns the received claims about the user.
     */
    getIdentityClaims(): object;
    /**
     * Returns the granted scopes from the server.
     */
    getGrantedScopes(): object;
    /**
     * Returns the current id_token.
     */
    getIdToken(): string;
    protected padBase64(base64data: any): string;
    /**
     * Returns the current access_token.
     */
    getAccessToken(): string;
    getRefreshToken(): string;
    /**
     * Returns the expiration date of the access_token
     * as milliseconds since 1970.
     */
    getAccessTokenExpiration(): number;
    protected getAccessTokenStoredAt(): number;
    protected getIdTokenStoredAt(): number;
    /**
     * Returns the expiration date of the id_token
     * as milliseconds since 1970.
     */
    getIdTokenExpiration(): number;
    /**
     * Checkes, whether there is a valid access_token.
     */
    hasValidAccessToken(): boolean;
    /**
     * Checks whether there is a valid id_token.
     */
    hasValidIdToken(): boolean;
    /**
     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.
     */
    getCustomTokenResponseProperty(requestedProperty: string): any;
    /**
     * Returns the auth-header that can be used
     * to transmit the access_token to a service
     */
    authorizationHeader(): string;
    /**
     * Removes all tokens and logs the user out.
     * If a logout url is configured, the user is
     * redirected to it with optional state parameter.
     * @param noRedirectToLogoutUrl
     * @param state
     */
    logOut(noRedirectToLogoutUrl?: boolean, state?: string): void;
    /**
     * @ignore
     */
    createAndSaveNonce(): Promise<string>;
    /**
     * @ignore
     */
    ngOnDestroy(): void;
    protected createNonce(): Promise<string>;
    protected checkAtHash(params: ValidationParams): Promise<boolean>;
    protected checkSignature(params: ValidationParams): Promise<any>;
    /**
     * Start the implicit flow or the code flow,
     * depending on your configuration.
     */
    initLoginFlow(additionalState?: string, params?: {}): void;
    /**
     * Starts the authorization code flow and redirects to user to
     * the auth servers login url.
     */
    initCodeFlow(additionalState?: string, params?: {}): void;
    private initCodeFlowInternal;
    protected createChallangeVerifierPairForPKCE(): Promise<[string, string]>;
    private extractRecognizedCustomParameters;
    /**
     * Revokes the auth token to secure the vulnarability
     * of the token issued allowing the authorization server to clean
     * up any security credentials associated with the authorization
     */
    revokeTokenAndLogout(): Promise<any>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OAuthService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<OAuthService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2F1dGgtc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJvYXV0aC1zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNWQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nWm9uZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvbkhhbmRsZXIsIFZhbGlkYXRpb25QYXJhbXMgfSBmcm9tICcuL3Rva2VuLXZhbGlkYXRpb24vdmFsaWRhdGlvbi1oYW5kbGVyJztcclxuaW1wb3J0IHsgVXJsSGVscGVyU2VydmljZSB9IGZyb20gJy4vdXJsLWhlbHBlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgT0F1dGhFdmVudCwgT0F1dGhTdWNjZXNzRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XHJcbmltcG9ydCB7IE9BdXRoTG9nZ2VyLCBPQXV0aFN0b3JhZ2UsIExvZ2luT3B0aW9ucywgUGFyc2VkSWRUb2tlbiwgT2lkY0Rpc2NvdmVyeURvYywgVG9rZW5SZXNwb25zZSwgVXNlckluZm8gfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgQXV0aENvbmZpZyB9IGZyb20gJy4vYXV0aC5jb25maWcnO1xyXG5pbXBvcnQgeyBIYXNoSGFuZGxlciB9IGZyb20gJy4vdG9rZW4tdmFsaWRhdGlvbi9oYXNoLWhhbmRsZXInO1xyXG4vKipcclxuICogU2VydmljZSBmb3IgbG9nZ2luZyBpbiBhbmQgbG9nZ2luZyBvdXQgd2l0aFxyXG4gKiBPSURDIGFuZCBPQXV0aDIuIFN1cHBvcnRzIGltcGxpY2l0IGZsb3cgYW5kXHJcbiAqIHBhc3N3b3JkIGZsb3cuXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBPQXV0aFNlcnZpY2UgZXh0ZW5kcyBBdXRoQ29uZmlnIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAgIHByb3RlY3RlZCBuZ1pvbmU6IE5nWm9uZTtcclxuICAgIHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogQXV0aENvbmZpZztcclxuICAgIHByb3RlY3RlZCB1cmxIZWxwZXI6IFVybEhlbHBlclNlcnZpY2U7XHJcbiAgICBwcm90ZWN0ZWQgbG9nZ2VyOiBPQXV0aExvZ2dlcjtcclxuICAgIHByb3RlY3RlZCBjcnlwdG86IEhhc2hIYW5kbGVyO1xyXG4gICAgcHJpdmF0ZSBkb2N1bWVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFZhbGlkYXRpb25IYW5kbGVyIHVzZWQgdG8gdmFsaWRhdGUgcmVjZWl2ZWRcclxuICAgICAqIGlkX3Rva2Vucy5cclxuICAgICAqL1xyXG4gICAgdG9rZW5WYWxpZGF0aW9uSGFuZGxlcjogVmFsaWRhdGlvbkhhbmRsZXI7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogRGVwcmVjYXRlZDogIHVzZSBwcm9wZXJ0eSBldmVudHMgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICBkaXNjb3ZlcnlEb2N1bWVudExvYWRlZDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBEZXByZWNhdGVkOiAgdXNlIHByb3BlcnR5IGV2ZW50cyBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIGRpc2NvdmVyeURvY3VtZW50TG9hZGVkJDogT2JzZXJ2YWJsZTxPaWRjRGlzY292ZXJ5RG9jPjtcclxuICAgIC8qKlxyXG4gICAgICogSW5mb3JtcyBhYm91dCBldmVudHMsIGxpa2UgdG9rZW5fcmVjZWl2ZWQgb3IgdG9rZW5fZXhwaXJlcy5cclxuICAgICAqIFNlZSB0aGUgc3RyaW5nIGVudW0gRXZlbnRUeXBlIGZvciBhIGZ1bGwgbGlzdCBvZiBldmVudCB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgZXZlbnRzOiBPYnNlcnZhYmxlPE9BdXRoRXZlbnQ+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVjZWl2ZWQgKHBhc3NlZCBhcm91bmQpIHN0YXRlLCB3aGVuIGxvZ2dpbmdcclxuICAgICAqIGluIHdpdGggaW1wbGljaXQgZmxvdy5cclxuICAgICAqL1xyXG4gICAgc3RhdGU/OiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgZXZlbnRzU3ViamVjdDogU3ViamVjdDxPQXV0aEV2ZW50PjtcclxuICAgIHByb3RlY3RlZCBkaXNjb3ZlcnlEb2N1bWVudExvYWRlZFN1YmplY3Q6IFN1YmplY3Q8T2lkY0Rpc2NvdmVyeURvYz47XHJcbiAgICBwcm90ZWN0ZWQgc2lsZW50UmVmcmVzaFBvc3RNZXNzYWdlRXZlbnRMaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjtcclxuICAgIHByb3RlY3RlZCBncmFudFR5cGVzU3VwcG9ydGVkOiBBcnJheTxzdHJpbmc+O1xyXG4gICAgcHJvdGVjdGVkIF9zdG9yYWdlOiBPQXV0aFN0b3JhZ2U7XHJcbiAgICBwcm90ZWN0ZWQgYWNjZXNzVG9rZW5UaW1lb3V0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcm90ZWN0ZWQgaWRUb2tlblRpbWVvdXRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuICAgIHByb3RlY3RlZCB0b2tlblJlY2VpdmVkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcm90ZWN0ZWQgc2Vzc2lvbkNoZWNrRXZlbnRMaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjtcclxuICAgIHByb3RlY3RlZCBqd2tzVXJpOiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgc2Vzc2lvbkNoZWNrVGltZXI6IGFueTtcclxuICAgIHByb3RlY3RlZCBzaWxlbnRSZWZyZXNoU3ViamVjdDogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIGluSW1wbGljaXRGbG93OiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIHNhdmVOb25jZXNJbkxvY2FsU3RvcmFnZTogYm9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKG5nWm9uZTogTmdab25lLCBodHRwOiBIdHRwQ2xpZW50LCBzdG9yYWdlOiBPQXV0aFN0b3JhZ2UsIHRva2VuVmFsaWRhdGlvbkhhbmRsZXI6IFZhbGlkYXRpb25IYW5kbGVyLCBjb25maWc6IEF1dGhDb25maWcsIHVybEhlbHBlcjogVXJsSGVscGVyU2VydmljZSwgbG9nZ2VyOiBPQXV0aExvZ2dlciwgY3J5cHRvOiBIYXNoSGFuZGxlciwgZG9jdW1lbnQ6IERvY3VtZW50KTtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNvbmZpZ3VyZSB0aGUgc2VydmljZVxyXG4gICAgICogQHBhcmFtIGNvbmZpZyB0aGUgY29uZmlndXJhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25maWd1cmUoY29uZmlnOiBBdXRoQ29uZmlnKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjb25maWdDaGFuZ2VkKCk6IHZvaWQ7XHJcbiAgICByZXN0YXJ0U2Vzc2lvbkNoZWNrc0lmU3RpbGxMb2dnZWRJbigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHJlc3RhcnRSZWZyZXNoVGltZXJJZlN0aWxsTG9nZ2VkSW4oKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzZXR1cFNlc3Npb25DaGVjaygpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIHNldHVwIHVwIHNpbGVudCByZWZyZXNoaW5nIGZvciB3aGVuIHRoZSB0b2tlbiBpc1xyXG4gICAgICogYWJvdXQgdG8gZXhwaXJlLiBXaGVuIHRoZSB1c2VyIGlzIGxvZ2dlZCBvdXQgdmlhIHRoaXMubG9nT3V0IG1ldGhvZCwgdGhlXHJcbiAgICAgKiBzaWxlbnQgcmVmcmVzaGluZyB3aWxsIHBhdXNlIGFuZCBub3QgcmVmcmVzaCB0aGUgdG9rZW5zIHVudGlsIHRoZSB1c2VyIGlzXHJcbiAgICAgKiBsb2dnZWQgYmFjayBpbiB2aWEgcmVjZWl2aW5nIGEgbmV3IHRva2VuLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBBZGRpdGlvbmFsIHBhcmFtZXRlciB0byBwYXNzXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuVG8gU2V0dXAgYXV0b21hdGljIHJlZnJlc2ggb2YgYSBzcGVjaWZpYyB0b2tlbiB0eXBlXHJcbiAgICAgKi9cclxuICAgIHNldHVwQXV0b21hdGljU2lsZW50UmVmcmVzaChwYXJhbXM/OiBvYmplY3QsIGxpc3RlblRvPzogJ2FjY2Vzc190b2tlbicgfCAnaWRfdG9rZW4nIHwgJ2FueScsIG5vUHJvbXB0PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgcmVmcmVzaEludGVybmFsKHBhcmFtczogYW55LCBub1Byb21wdDogYW55KTogUHJvbWlzZTxUb2tlblJlc3BvbnNlIHwgT0F1dGhFdmVudD47XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGZpcnN0IGNhbGxzIGBsb2FkRGlzY292ZXJ5RG9jdW1lbnQoLi4uKWAgYW5kXHJcbiAgICAgKiBkaXJlY3RseSBjaGFpbnMgdXNpbmcgdGhlIGB0aGVuKC4uLilgIHBhcnQgb2YgdGhlIHByb21pc2UgdG8gY2FsbFxyXG4gICAgICogdGhlIGB0cnlMb2dpbiguLi4pYCBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgTG9naW5PcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBgdHJ5TG9naW4oLi4uKWBcclxuICAgICAqL1xyXG4gICAgbG9hZERpc2NvdmVyeURvY3VtZW50QW5kVHJ5TG9naW4ob3B0aW9ucz86IExvZ2luT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGZpcnN0IGNhbGxzIGBsb2FkRGlzY292ZXJ5RG9jdW1lbnRBbmRUcnlMb2dpbiguLi4pYFxyXG4gICAgICogYW5kIGlmIHRoZW4gY2hhaW5zIHRvIGBpbml0TG9naW5GbG93KClgLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyB2YWxpZFxyXG4gICAgICogSWRUb2tlbiBvciBubyB2YWxpZCBBY2Nlc3NUb2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBMb2dpbk9wdGlvbnMgdG8gcGFzcyB0aHJvdWdoIHRvIGB0cnlMb2dpbiguLi4pYFxyXG4gICAgICovXHJcbiAgICBsb2FkRGlzY292ZXJ5RG9jdW1lbnRBbmRMb2dpbihvcHRpb25zPzogTG9naW5PcHRpb25zICYge1xyXG4gICAgICAgIHN0YXRlPzogc3RyaW5nO1xyXG4gICAgfSk6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICBwcm90ZWN0ZWQgZGVidWcoLi4uYXJnczogYW55W10pOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlVXJsRnJvbURpc2NvdmVyeURvY3VtZW50KHVybDogc3RyaW5nKTogc3RyaW5nW107XHJcbiAgICBwcm90ZWN0ZWQgdmFsaWRhdGVVcmxGb3JIdHRwcyh1cmw6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgYXNzZXJ0VXJsTm90TnVsbEFuZENvcnJlY3RQcm90b2NvbCh1cmw6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZyk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgdmFsaWRhdGVVcmxBZ2FpbnN0SXNzdWVyKHVybDogc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBzZXR1cFJlZnJlc2hUaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHNldHVwRXhwaXJhdGlvblRpbWVycygpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHNldHVwQWNjZXNzVG9rZW5UaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHNldHVwSWRUb2tlblRpbWVyKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRpbWVycyBmb3IgYXV0b21hdGljIHJlZnJlc2guXHJcbiAgICAgKiBUbyByZXN0YXJ0IGl0LCBjYWxsIHNldHVwQXV0b21hdGljU2lsZW50UmVmcmVzaCBhZ2Fpbi5cclxuICAgICAqL1xyXG4gICAgc3RvcEF1dG9tYXRpY1JlZnJlc2goKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjbGVhckFjY2Vzc1Rva2VuVGltZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjbGVhcklkVG9rZW5UaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGNhbGNUaW1lb3V0KHN0b3JlZEF0OiBudW1iZXIsIGV4cGlyYXRpb246IG51bWJlcik6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogREVQUkVDQVRFRC4gVXNlIGEgcHJvdmlkZXIgZm9yIE9BdXRoU3RvcmFnZSBpbnN0ZWFkOlxyXG4gICAgICpcclxuICAgICAqIHsgcHJvdmlkZTogT0F1dGhTdG9yYWdlLCB1c2VGYWN0b3J5OiBvQXV0aFN0b3JhZ2VGYWN0b3J5IH1cclxuICAgICAqIGV4cG9ydCBmdW5jdGlvbiBvQXV0aFN0b3JhZ2VGYWN0b3J5KCk6IE9BdXRoU3RvcmFnZSB7IHJldHVybiBsb2NhbFN0b3JhZ2U7IH1cclxuICAgICAqIFNldHMgYSBjdXN0b20gc3RvcmFnZSB1c2VkIHRvIHN0b3JlIHRoZSByZWNlaXZlZFxyXG4gICAgICogdG9rZW5zIG9uIGNsaWVudCBzaWRlLiBCeSBkZWZhdWx0LCB0aGUgYnJvd3NlcidzXHJcbiAgICAgKiBzZXNzaW9uU3RvcmFnZSBpcyB1c2VkLlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdG9yYWdlXHJcbiAgICAgKi9cclxuICAgIHNldFN0b3JhZ2Uoc3RvcmFnZTogT0F1dGhTdG9yYWdlKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhlIGRpc2NvdmVyeSBkb2N1bWVudCB0byBjb25maWd1cmUgbW9zdFxyXG4gICAgICogcHJvcGVydGllcyBvZiB0aGlzIHNlcnZpY2UuIFRoZSB1cmwgb2YgdGhlIGRpc2NvdmVyeVxyXG4gICAgICogZG9jdW1lbnQgaXMgaW5mZXJlZCBmcm9tIHRoZSBpc3N1ZXIncyB1cmwgYWNjb3JkaW5nXHJcbiAgICAgKiB0byB0aGUgT3BlbklkIENvbm5lY3Qgc3BlYy4gVG8gdXNlIGFub3RoZXIgdXJsIHlvdVxyXG4gICAgICogY2FuIHBhc3MgaXQgdG8gdG8gb3B0aW9uYWwgcGFyYW1ldGVyIGZ1bGxVcmwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bGxVcmxcclxuICAgICAqL1xyXG4gICAgbG9hZERpc2NvdmVyeURvY3VtZW50KGZ1bGxVcmw/OiBzdHJpbmcpOiBQcm9taXNlPE9BdXRoU3VjY2Vzc0V2ZW50PjtcclxuICAgIHByb3RlY3RlZCBsb2FkSndrcygpOiBQcm9taXNlPG9iamVjdD47XHJcbiAgICBwcm90ZWN0ZWQgdmFsaWRhdGVEaXNjb3ZlcnlEb2N1bWVudChkb2M6IE9pZGNEaXNjb3ZlcnlEb2MpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHBhc3N3b3JkIGZsb3cgdG8gZXhjaGFuZ2UgdXNlck5hbWUgYW5kIHBhc3N3b3JkIGZvciBhblxyXG4gICAgICogYWNjZXNzX3Rva2VuLiBBZnRlciByZWNlaXZpbmcgdGhlIGFjY2Vzc190b2tlbiwgdGhpcyBtZXRob2RcclxuICAgICAqIHVzZXMgaXQgdG8gcXVlcnkgdGhlIHVzZXJpbmZvIGVuZHBvaW50IGluIG9yZGVyIHRvIGdldCBpbmZvcm1hdGlvblxyXG4gICAgICogYWJvdXQgdGhlIHVzZXIgaW4gcXVlc3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiB1c2luZyB0aGlzLCBtYWtlIHN1cmUgdGhhdCB0aGUgcHJvcGVydHkgb2lkYyBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgICAgKiBPdGhlcndpc2Ugc3RyaWN0ZXIgdmFsaWRhdGlvbnMgdGFrZSBwbGFjZSB0aGF0IG1ha2UgdGhpcyBvcGVyYXRpb25cclxuICAgICAqIGZhaWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJOYW1lXHJcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSBoZWFkZXJzIE9wdGlvbmFsIGFkZGl0aW9uYWwgaHR0cC1oZWFkZXJzLlxyXG4gICAgICovXHJcbiAgICBmZXRjaFRva2VuVXNpbmdQYXNzd29yZEZsb3dBbmRMb2FkVXNlclByb2ZpbGUodXNlck5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgaGVhZGVycz86IEh0dHBIZWFkZXJzKTogUHJvbWlzZTxVc2VySW5mbz47XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSB1c2VyIHByb2ZpbGUgYnkgYWNjZXNzaW5nIHRoZSB1c2VyIGluZm8gZW5kcG9pbnQgZGVmaW5lZCBieSBPcGVuSWQgQ29ubmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHVzaW5nIHRoaXMgd2l0aCBPQXV0aDIgcGFzc3dvcmQgZmxvdywgbWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IG9pZGMgaXMgc2V0IHRvIGZhbHNlLlxyXG4gICAgICogT3RoZXJ3aXNlIHN0cmljdGVyIHZhbGlkYXRpb25zIHRha2UgcGxhY2UgdGhhdCBtYWtlIHRoaXMgb3BlcmF0aW9uIGZhaWwuXHJcbiAgICAgKi9cclxuICAgIGxvYWRVc2VyUHJvZmlsZSgpOiBQcm9taXNlPFVzZXJJbmZvPjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlcyBwYXNzd29yZCBmbG93IHRvIGV4Y2hhbmdlIHVzZXJOYW1lIGFuZCBwYXNzd29yZCBmb3IgYW4gYWNjZXNzX3Rva2VuLlxyXG4gICAgICogQHBhcmFtIHVzZXJOYW1lXHJcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSBoZWFkZXJzIE9wdGlvbmFsIGFkZGl0aW9uYWwgaHR0cC1oZWFkZXJzLlxyXG4gICAgICovXHJcbiAgICBmZXRjaFRva2VuVXNpbmdQYXNzd29yZEZsb3codXNlck5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgaGVhZGVycz86IEh0dHBIZWFkZXJzKTogUHJvbWlzZTxUb2tlblJlc3BvbnNlPjtcclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSB0b2tlbiB1c2luZyBhIHJlZnJlc2hfdG9rZW4uXHJcbiAgICAgKiBUaGlzIGRvZXMgbm90IHdvcmsgZm9yIGltcGxpY2l0IGZsb3csIGIvY1xyXG4gICAgICogdGhlcmUgaXMgbm8gcmVmcmVzaF90b2tlbiBpbiB0aGlzIGZsb3cuXHJcbiAgICAgKiBBIHNvbHV0aW9uIGZvciB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZVxyXG4gICAgICogbWV0aG9kIHNpbGVudFJlZnJlc2guXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hUb2tlbigpOiBQcm9taXNlPFRva2VuUmVzcG9uc2U+O1xyXG4gICAgcHJvdGVjdGVkIHJlbW92ZVNpbGVudFJlZnJlc2hFdmVudExpc3RlbmVyKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgc2V0dXBTaWxlbnRSZWZyZXNoRXZlbnRMaXN0ZW5lcigpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHNpbGVudCByZWZyZXNoIGZvciBpbXBsaWNpdCBmbG93LlxyXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBuZXcgdG9rZW5zIHdoZW4vYmVmb3JlXHJcbiAgICAgKiB0aGUgZXhpc3RpbmcgdG9rZW5zIGV4cGlyZS5cclxuICAgICAqL1xyXG4gICAgc2lsZW50UmVmcmVzaChwYXJhbXM/OiBvYmplY3QsIG5vUHJvbXB0PzogYm9vbGVhbik6IFByb21pc2U8T0F1dGhFdmVudD47XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgKiB7QGxpbmsgT0F1dGhTZXJ2aWNlI2luaXRMb2dpbkZsb3dJblBvcHVwfSBoYW5kbGVzIGJvdGggY29kZVxyXG4gICAgICogYW5kIGltcGxpY2l0IGZsb3dzLlxyXG4gICAgICovXHJcbiAgICBpbml0SW1wbGljaXRGbG93SW5Qb3B1cChvcHRpb25zPzoge1xyXG4gICAgICAgIGhlaWdodD86IG51bWJlcjtcclxuICAgICAgICB3aWR0aD86IG51bWJlcjtcclxuICAgIH0pOiBQcm9taXNlPHVua25vd24+O1xyXG4gICAgaW5pdExvZ2luRmxvd0luUG9wdXAob3B0aW9ucz86IHtcclxuICAgICAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICAgICAgd2lkdGg/OiBudW1iZXI7XHJcbiAgICB9KTogUHJvbWlzZTx1bmtub3duPjtcclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVQb3B1cEZlYXR1cmVzKG9wdGlvbnM6IHtcclxuICAgICAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICAgICAgd2lkdGg/OiBudW1iZXI7XHJcbiAgICB9KTogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NNZXNzYWdlRXZlbnRNZXNzYWdlKGU6IE1lc3NhZ2VFdmVudCk6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBjYW5QZXJmb3JtU2Vzc2lvbkNoZWNrKCk6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgc2V0dXBTZXNzaW9uQ2hlY2tFdmVudExpc3RlbmVyKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlU2Vzc2lvblVuY2hhbmdlZCgpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVNlc3Npb25DaGFuZ2UoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCB3YWl0Rm9yU2lsZW50UmVmcmVzaEFmdGVyU2Vzc2lvbkNoYW5nZSgpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVNlc3Npb25FcnJvcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHJlbW92ZVNlc3Npb25DaGVja0V2ZW50TGlzdGVuZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBpbml0U2Vzc2lvbkNoZWNrKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgc3RhcnRTZXNzaW9uQ2hlY2tUaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHN0b3BTZXNzaW9uQ2hlY2tUaW1lcigpOiB2b2lkO1xyXG4gICAgY2hlY2tTZXNzaW9uKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlTG9naW5Vcmwoc3RhdGU/OiBzdHJpbmcsIGxvZ2luSGludD86IHN0cmluZywgY3VzdG9tUmVkaXJlY3RVcmk/OiBzdHJpbmcsIG5vUHJvbXB0PzogYm9vbGVhbiwgcGFyYW1zPzogb2JqZWN0KTogUHJvbWlzZTxzdHJpbmc+O1xyXG4gICAgaW5pdEltcGxpY2l0Rmxvd0ludGVybmFsKGFkZGl0aW9uYWxTdGF0ZT86IHN0cmluZywgcGFyYW1zPzogc3RyaW5nIHwgb2JqZWN0KTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBpbXBsaWNpdCBmbG93IGFuZCByZWRpcmVjdHMgdG8gdXNlciB0b1xyXG4gICAgICogdGhlIGF1dGggc2VydmVycycgbG9naW4gdXJsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsU3RhdGUgT3B0aW9uYWwgc3RhdGUgdGhhdCBpcyBwYXNzZWQgYXJvdW5kLlxyXG4gICAgICogIFlvdSdsbCBmaW5kIHRoaXMgc3RhdGUgaW4gdGhlIHByb3BlcnR5IGBzdGF0ZWAgYWZ0ZXIgYHRyeUxvZ2luYCBsb2dnZWQgaW4gdGhlIHVzZXIuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEhhc2ggd2l0aCBhZGRpdGlvbmFsIHBhcmFtZXRlci4gSWYgaXQgaXMgYSBzdHJpbmcsIGl0IGlzIHVzZWQgZm9yIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICBwYXJhbWV0ZXIgbG9naW5IaW50IChmb3IgdGhlIHNha2Ugb2YgY29tcGF0aWJpbGl0eSB3aXRoIGZvcm1lciB2ZXJzaW9ucylcclxuICAgICAqL1xyXG4gICAgaW5pdEltcGxpY2l0RmxvdyhhZGRpdGlvbmFsU3RhdGU/OiBzdHJpbmcsIHBhcmFtcz86IHN0cmluZyB8IG9iamVjdCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGN1cnJlbnQgaW1wbGljaXQgZmxvd1xyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCBhbGxvd3MgcmVzZXR0aW5nIHRoZSBjdXJyZW50IGltcGxpY3QgZmxvdyBpbiBvcmRlciB0byBiZSBpbml0aWFsaXplZCBhZ2Fpbi5cclxuICAgICAqL1xyXG4gICAgcmVzZXRJbXBsaWNpdEZsb3coKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjYWxsT25Ub2tlblJlY2VpdmVkSWZFeGlzdHMob3B0aW9uczogTG9naW5PcHRpb25zKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzdG9yZUFjY2Vzc1Rva2VuUmVzcG9uc2UoYWNjZXNzVG9rZW46IHN0cmluZywgcmVmcmVzaFRva2VuOiBzdHJpbmcsIGV4cGlyZXNJbjogbnVtYmVyLCBncmFudGVkU2NvcGVzOiBTdHJpbmcsIGN1c3RvbVBhcmFtZXRlcnM/OiBNYXA8c3RyaW5nLCBzdHJpbmc+KTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGVzIHRvIHRyeUxvZ2luSW1wbGljaXRGbG93IGZvciB0aGUgc2FrZSBvZiBjb21wZXRhYmlsaXR5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICB0cnlMb2dpbihvcHRpb25zPzogTG9naW5PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcclxuICAgIHByaXZhdGUgcGFyc2VRdWVyeVN0cmluZztcclxuICAgIHRyeUxvZ2luQ29kZUZsb3cob3B0aW9ucz86IExvZ2luT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSByZXR1cm5lZCBhdXRoIGNvZGUgZnJvbSB0aGUgcmVkaXJlY3QgdXJpIHRoYXQgaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgICogSWYgcmVxdWlyZWQgYWxzbyBjaGVjayBoYXNoLCBhcyB3ZSBjb3VsZCB1c2UgaGFzaCBsb2NhdGlvbiBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb2RlUGFydHNGcm9tVXJsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdG9rZW4gdXNpbmcgYW4gaW50ZXJtZWRpYXRlIGNvZGUuIFdvcmtzIGZvciB0aGUgQXV0aG9yaXphdGlvbiBDb2RlIGZsb3cuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0VG9rZW5Gcm9tQ29kZTtcclxuICAgIHByaXZhdGUgZmV0Y2hBbmRQcm9jZXNzVG9rZW47XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZXJlIGFyZSB0b2tlbnMgaW4gdGhlIGhhc2ggZnJhZ21lbnRcclxuICAgICAqIGFzIGEgcmVzdWx0IG9mIHRoZSBpbXBsaWNpdCBmbG93LiBUaGVzZSB0b2tlbnMgYXJlXHJcbiAgICAgKiBwYXJzZWQsIHZhbGlkYXRlZCBhbmQgdXNlZCB0byBzaWduIHRoZSB1c2VyIGluIHRvIHRoZVxyXG4gICAgICogY3VycmVudCBjbGllbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdHJ5TG9naW5JbXBsaWNpdEZsb3cob3B0aW9ucz86IExvZ2luT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICBwcml2YXRlIHBhcnNlU3RhdGU7XHJcbiAgICBwcm90ZWN0ZWQgdmFsaWRhdGVOb25jZShub25jZUluU3RhdGU6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgc3RvcmVJZFRva2VuKGlkVG9rZW46IFBhcnNlZElkVG9rZW4pOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHN0b3JlU2Vzc2lvblN0YXRlKHNlc3Npb25TdGF0ZTogc3RyaW5nKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBnZXRTZXNzaW9uU3RhdGUoKTogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZUxvZ2luRXJyb3Iob3B0aW9uczogTG9naW5PcHRpb25zLCBwYXJ0czogb2JqZWN0KTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzSWRUb2tlbihpZFRva2VuOiBzdHJpbmcsIGFjY2Vzc1Rva2VuOiBzdHJpbmcsIHNraXBOb25jZUNoZWNrPzogYm9vbGVhbik6IFByb21pc2U8UGFyc2VkSWRUb2tlbj47XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlY2VpdmVkIGNsYWltcyBhYm91dCB0aGUgdXNlci5cclxuICAgICAqL1xyXG4gICAgZ2V0SWRlbnRpdHlDbGFpbXMoKTogb2JqZWN0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBncmFudGVkIHNjb3BlcyBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIGdldEdyYW50ZWRTY29wZXMoKTogb2JqZWN0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGlkX3Rva2VuLlxyXG4gICAgICovXHJcbiAgICBnZXRJZFRva2VuKCk6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBwYWRCYXNlNjQoYmFzZTY0ZGF0YTogYW55KTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFjY2Vzc190b2tlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0QWNjZXNzVG9rZW4oKTogc3RyaW5nO1xyXG4gICAgZ2V0UmVmcmVzaFRva2VuKCk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZXhwaXJhdGlvbiBkYXRlIG9mIHRoZSBhY2Nlc3NfdG9rZW5cclxuICAgICAqIGFzIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwLlxyXG4gICAgICovXHJcbiAgICBnZXRBY2Nlc3NUb2tlbkV4cGlyYXRpb24oKTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGdldEFjY2Vzc1Rva2VuU3RvcmVkQXQoKTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGdldElkVG9rZW5TdG9yZWRBdCgpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGV4cGlyYXRpb24gZGF0ZSBvZiB0aGUgaWRfdG9rZW5cclxuICAgICAqIGFzIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwLlxyXG4gICAgICovXHJcbiAgICBnZXRJZFRva2VuRXhwaXJhdGlvbigpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrZXMsIHdoZXRoZXIgdGhlcmUgaXMgYSB2YWxpZCBhY2Nlc3NfdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIGhhc1ZhbGlkQWNjZXNzVG9rZW4oKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSB2YWxpZCBpZF90b2tlbi5cclxuICAgICAqL1xyXG4gICAgaGFzVmFsaWRJZFRva2VuKCk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgc2F2ZWQgY3VzdG9tIHByb3BlcnR5IG9mIHRoZSBUb2tlblJlcG9uc2Ugb2JqZWN0LiBPbmx5IGlmIHByZWRlZmluZWQgaW4gYXV0aGNvbmZpZy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VzdG9tVG9rZW5SZXNwb25zZVByb3BlcnR5KHJlcXVlc3RlZFByb3BlcnR5OiBzdHJpbmcpOiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF1dGgtaGVhZGVyIHRoYXQgY2FuIGJlIHVzZWRcclxuICAgICAqIHRvIHRyYW5zbWl0IHRoZSBhY2Nlc3NfdG9rZW4gdG8gYSBzZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGF1dGhvcml6YXRpb25IZWFkZXIoKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCB0b2tlbnMgYW5kIGxvZ3MgdGhlIHVzZXIgb3V0LlxyXG4gICAgICogSWYgYSBsb2dvdXQgdXJsIGlzIGNvbmZpZ3VyZWQsIHRoZSB1c2VyIGlzXHJcbiAgICAgKiByZWRpcmVjdGVkIHRvIGl0IHdpdGggb3B0aW9uYWwgc3RhdGUgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIG5vUmVkaXJlY3RUb0xvZ291dFVybFxyXG4gICAgICogQHBhcmFtIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIGxvZ091dChub1JlZGlyZWN0VG9Mb2dvdXRVcmw/OiBib29sZWFuLCBzdGF0ZT86IHN0cmluZyk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlQW5kU2F2ZU5vbmNlKCk6IFByb21pc2U8c3RyaW5nPjtcclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZU5vbmNlKCk6IFByb21pc2U8c3RyaW5nPjtcclxuICAgIHByb3RlY3RlZCBjaGVja0F0SGFzaChwYXJhbXM6IFZhbGlkYXRpb25QYXJhbXMpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgcHJvdGVjdGVkIGNoZWNrU2lnbmF0dXJlKHBhcmFtczogVmFsaWRhdGlvblBhcmFtcyk6IFByb21pc2U8YW55PjtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdGhlIGltcGxpY2l0IGZsb3cgb3IgdGhlIGNvZGUgZmxvdyxcclxuICAgICAqIGRlcGVuZGluZyBvbiB5b3VyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGluaXRMb2dpbkZsb3coYWRkaXRpb25hbFN0YXRlPzogc3RyaW5nLCBwYXJhbXM/OiB7fSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIGZsb3cgYW5kIHJlZGlyZWN0cyB0byB1c2VyIHRvXHJcbiAgICAgKiB0aGUgYXV0aCBzZXJ2ZXJzIGxvZ2luIHVybC5cclxuICAgICAqL1xyXG4gICAgaW5pdENvZGVGbG93KGFkZGl0aW9uYWxTdGF0ZT86IHN0cmluZywgcGFyYW1zPzoge30pOiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBpbml0Q29kZUZsb3dJbnRlcm5hbDtcclxuICAgIHByb3RlY3RlZCBjcmVhdGVDaGFsbGFuZ2VWZXJpZmllclBhaXJGb3JQS0NFKCk6IFByb21pc2U8W3N0cmluZywgc3RyaW5nXT47XHJcbiAgICBwcml2YXRlIGV4dHJhY3RSZWNvZ25pemVkQ3VzdG9tUGFyYW1ldGVycztcclxuICAgIC8qKlxyXG4gICAgICogUmV2b2tlcyB0aGUgYXV0aCB0b2tlbiB0byBzZWN1cmUgdGhlIHZ1bG5hcmFiaWxpdHlcclxuICAgICAqIG9mIHRoZSB0b2tlbiBpc3N1ZWQgYWxsb3dpbmcgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyIHRvIGNsZWFuXHJcbiAgICAgKiB1cCBhbnkgc2VjdXJpdHkgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBhdXRob3JpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIHJldm9rZVRva2VuQW5kTG9nb3V0KCk6IFByb21pc2U8YW55PjtcclxufVxyXG4iXX0=