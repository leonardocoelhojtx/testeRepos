/**
 * native-date-time-adapter.class
 */
import { Platform } from '@angular/cdk/platform';
import { DateTimeAdapter } from './date-time-adapter.class';
import * as ɵngcc0 from '@angular/core';
export declare class NativeDateTimeAdapter extends DateTimeAdapter<Date> {
    private owlDateTimeLocale;
    /** Whether to clamp the date between 1 and 9999 to avoid IE and Edge errors. */
    private readonly _clampDate;
    /**
     * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
     * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
     * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
     * will produce `'8/13/1800'`.
     */
    useUtcForDisplay: boolean;
    constructor(owlDateTimeLocale: string, platform: Platform);
    getYear(date: Date): number;
    getMonth(date: Date): number;
    getDay(date: Date): number;
    getDate(date: Date): number;
    getHours(date: Date): number;
    getMinutes(date: Date): number;
    getSeconds(date: Date): number;
    getTime(date: Date): number;
    getNumDaysInMonth(date: Date): number;
    differenceInCalendarDays(dateLeft: Date, dateRight: Date): number;
    getYearName(date: Date): string;
    getMonthNames(style: 'long' | 'short' | 'narrow'): string[];
    getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];
    getDateNames(): string[];
    toIso8601(date: Date): string;
    isEqual(dateLeft: Date, dateRight: Date): boolean;
    isSameDay(dateLeft: Date, dateRight: Date): boolean;
    isValid(date: Date): boolean;
    invalid(): Date;
    isDateInstance(obj: any): boolean;
    addCalendarYears(date: Date, amount: number): Date;
    addCalendarMonths(date: Date, amount: number): Date;
    addCalendarDays(date: Date, amount: number): Date;
    setHours(date: Date, amount: number): Date;
    setMinutes(date: Date, amount: number): Date;
    setSeconds(date: Date, amount: number): Date;
    createDate(year: number, month: number, date: number, hours?: number, minutes?: number, seconds?: number): Date;
    clone(date: Date): Date;
    now(): Date;
    format(date: Date, displayFormat: any): string;
    parse(value: any, parseFormat: any): Date | null;
    /**
     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
     * invalid date for all other values.
     */
    deserialize(value: any): Date | null;
    /**
     * Creates a date but allows the month and date to overflow.
     */
    private createDateWithOverflow;
    /**
     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
     * other browsers do not. We remove them to make output consistent and because they interfere with
     * date parsing.
     */
    private stripDirectionalityCharacters;
    /**
     * When converting Date object to string, javascript built-in functions may return wrong
     * results because it applies its internal DST rules. The DST rules around the world change
     * very frequently, and the current valid rule is not always valid in previous years though.
     * We work around this problem building a new Date object which has its internal UTC
     * representation with the local date and time.
     */
    private _format;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NativeDateTimeAdapter>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NativeDateTimeAdapter>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlLWRhdGUtdGltZS1hZGFwdGVyLmNsYXNzLmQudHMiLCJzb3VyY2VzIjpbIm5hdGl2ZS1kYXRlLXRpbWUtYWRhcHRlci5jbGFzcy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUVBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBuYXRpdmUtZGF0ZS10aW1lLWFkYXB0ZXIuY2xhc3NcbiAqL1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgRGF0ZVRpbWVBZGFwdGVyIH0gZnJvbSAnLi9kYXRlLXRpbWUtYWRhcHRlci5jbGFzcyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYXRpdmVEYXRlVGltZUFkYXB0ZXIgZXh0ZW5kcyBEYXRlVGltZUFkYXB0ZXI8RGF0ZT4ge1xuICAgIHByaXZhdGUgb3dsRGF0ZVRpbWVMb2NhbGU7XG4gICAgLyoqIFdoZXRoZXIgdG8gY2xhbXAgdGhlIGRhdGUgYmV0d2VlbiAxIGFuZCA5OTk5IHRvIGF2b2lkIElFIGFuZCBFZGdlIGVycm9ycy4gKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9jbGFtcERhdGU7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byB1c2UgYHRpbWVab25lOiAndXRjJ2Agd2l0aCBgSW50bC5EYXRlVGltZUZvcm1hdGAgd2hlbiBmb3JtYXR0aW5nIGRhdGVzLlxuICAgICAqIFdpdGhvdXQgdGhpcyBgSW50bC5EYXRlVGltZUZvcm1hdGAgc29tZXRpbWVzIGNob29zZXMgdGhlIHdyb25nIHRpbWVab25lLCB3aGljaCBjYW4gdGhyb3cgb2ZmXG4gICAgICogdGhlIHJlc3VsdC4gKGUuZy4gaW4gdGhlIGVuLVVTIGxvY2FsZSBgbmV3IERhdGUoMTgwMCwgNywgMTQpLnRvTG9jYWxlRGF0ZVN0cmluZygpYFxuICAgICAqIHdpbGwgcHJvZHVjZSBgJzgvMTMvMTgwMCdgLlxuICAgICAqL1xuICAgIHVzZVV0Y0ZvckRpc3BsYXk6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3Iob3dsRGF0ZVRpbWVMb2NhbGU6IHN0cmluZywgcGxhdGZvcm06IFBsYXRmb3JtKTtcbiAgICBnZXRZZWFyKGRhdGU6IERhdGUpOiBudW1iZXI7XG4gICAgZ2V0TW9udGgoZGF0ZTogRGF0ZSk6IG51bWJlcjtcbiAgICBnZXREYXkoZGF0ZTogRGF0ZSk6IG51bWJlcjtcbiAgICBnZXREYXRlKGRhdGU6IERhdGUpOiBudW1iZXI7XG4gICAgZ2V0SG91cnMoZGF0ZTogRGF0ZSk6IG51bWJlcjtcbiAgICBnZXRNaW51dGVzKGRhdGU6IERhdGUpOiBudW1iZXI7XG4gICAgZ2V0U2Vjb25kcyhkYXRlOiBEYXRlKTogbnVtYmVyO1xuICAgIGdldFRpbWUoZGF0ZTogRGF0ZSk6IG51bWJlcjtcbiAgICBnZXROdW1EYXlzSW5Nb250aChkYXRlOiBEYXRlKTogbnVtYmVyO1xuICAgIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXRlTGVmdDogRGF0ZSwgZGF0ZVJpZ2h0OiBEYXRlKTogbnVtYmVyO1xuICAgIGdldFllYXJOYW1lKGRhdGU6IERhdGUpOiBzdHJpbmc7XG4gICAgZ2V0TW9udGhOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW107XG4gICAgZ2V0RGF5T2ZXZWVrTmFtZXMoc3R5bGU6ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93Jyk6IHN0cmluZ1tdO1xuICAgIGdldERhdGVOYW1lcygpOiBzdHJpbmdbXTtcbiAgICB0b0lzbzg2MDEoZGF0ZTogRGF0ZSk6IHN0cmluZztcbiAgICBpc0VxdWFsKGRhdGVMZWZ0OiBEYXRlLCBkYXRlUmlnaHQ6IERhdGUpOiBib29sZWFuO1xuICAgIGlzU2FtZURheShkYXRlTGVmdDogRGF0ZSwgZGF0ZVJpZ2h0OiBEYXRlKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGRhdGU6IERhdGUpOiBib29sZWFuO1xuICAgIGludmFsaWQoKTogRGF0ZTtcbiAgICBpc0RhdGVJbnN0YW5jZShvYmo6IGFueSk6IGJvb2xlYW47XG4gICAgYWRkQ2FsZW5kYXJZZWFycyhkYXRlOiBEYXRlLCBhbW91bnQ6IG51bWJlcik6IERhdGU7XG4gICAgYWRkQ2FsZW5kYXJNb250aHMoZGF0ZTogRGF0ZSwgYW1vdW50OiBudW1iZXIpOiBEYXRlO1xuICAgIGFkZENhbGVuZGFyRGF5cyhkYXRlOiBEYXRlLCBhbW91bnQ6IG51bWJlcik6IERhdGU7XG4gICAgc2V0SG91cnMoZGF0ZTogRGF0ZSwgYW1vdW50OiBudW1iZXIpOiBEYXRlO1xuICAgIHNldE1pbnV0ZXMoZGF0ZTogRGF0ZSwgYW1vdW50OiBudW1iZXIpOiBEYXRlO1xuICAgIHNldFNlY29uZHMoZGF0ZTogRGF0ZSwgYW1vdW50OiBudW1iZXIpOiBEYXRlO1xuICAgIGNyZWF0ZURhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIsIGhvdXJzPzogbnVtYmVyLCBtaW51dGVzPzogbnVtYmVyLCBzZWNvbmRzPzogbnVtYmVyKTogRGF0ZTtcbiAgICBjbG9uZShkYXRlOiBEYXRlKTogRGF0ZTtcbiAgICBub3coKTogRGF0ZTtcbiAgICBmb3JtYXQoZGF0ZTogRGF0ZSwgZGlzcGxheUZvcm1hdDogYW55KTogc3RyaW5nO1xuICAgIHBhcnNlKHZhbHVlOiBhbnksIHBhcnNlRm9ybWF0OiBhbnkpOiBEYXRlIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSBpZiBnaXZlbiBhIHZhbGlkIERhdGUgb3IgbnVsbC4gRGVzZXJpYWxpemVzIHZhbGlkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgKiAoaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBpbnRvIHZhbGlkIERhdGVzIGFuZCBlbXB0eSBzdHJpbmcgaW50byBudWxsLiBSZXR1cm5zIGFuXG4gICAgICogaW52YWxpZCBkYXRlIGZvciBhbGwgb3RoZXIgdmFsdWVzLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGF0ZSBidXQgYWxsb3dzIHRoZSBtb250aCBhbmQgZGF0ZSB0byBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZURhdGVXaXRoT3ZlcmZsb3c7XG4gICAgLyoqXG4gICAgICogU3RyaXAgb3V0IHVuaWNvZGUgTFRSIGFuZCBSVEwgY2hhcmFjdGVycy4gRWRnZSBhbmQgSUUgaW5zZXJ0IHRoZXNlIGludG8gZm9ybWF0dGVkIGRhdGVzIHdoaWxlXG4gICAgICogb3RoZXIgYnJvd3NlcnMgZG8gbm90LiBXZSByZW1vdmUgdGhlbSB0byBtYWtlIG91dHB1dCBjb25zaXN0ZW50IGFuZCBiZWNhdXNlIHRoZXkgaW50ZXJmZXJlIHdpdGhcbiAgICAgKiBkYXRlIHBhcnNpbmcuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycztcbiAgICAvKipcbiAgICAgKiBXaGVuIGNvbnZlcnRpbmcgRGF0ZSBvYmplY3QgdG8gc3RyaW5nLCBqYXZhc2NyaXB0IGJ1aWx0LWluIGZ1bmN0aW9ucyBtYXkgcmV0dXJuIHdyb25nXG4gICAgICogcmVzdWx0cyBiZWNhdXNlIGl0IGFwcGxpZXMgaXRzIGludGVybmFsIERTVCBydWxlcy4gVGhlIERTVCBydWxlcyBhcm91bmQgdGhlIHdvcmxkIGNoYW5nZVxuICAgICAqIHZlcnkgZnJlcXVlbnRseSwgYW5kIHRoZSBjdXJyZW50IHZhbGlkIHJ1bGUgaXMgbm90IGFsd2F5cyB2YWxpZCBpbiBwcmV2aW91cyB5ZWFycyB0aG91Z2guXG4gICAgICogV2Ugd29yayBhcm91bmQgdGhpcyBwcm9ibGVtIGJ1aWxkaW5nIGEgbmV3IERhdGUgb2JqZWN0IHdoaWNoIGhhcyBpdHMgaW50ZXJuYWwgVVRDXG4gICAgICogcmVwcmVzZW50YXRpb24gd2l0aCB0aGUgbG9jYWwgZGF0ZSBhbmQgdGltZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9mb3JtYXQ7XG59XG4iXX0=