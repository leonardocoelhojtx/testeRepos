/**
 * calendar-multi-year-view.component
 */
import { AfterContentInit, ChangeDetectorRef, EventEmitter, OnInit } from '@angular/core';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { CalendarCell, OwlCalendarBodyComponent } from './calendar-body.component';
import { SelectMode } from './date-time.class';
import { OwlDateTimeIntl } from './date-time-picker-intl.service';
import * as ɵngcc0 from '@angular/core';
export declare const YEARS_PER_ROW = 3;
export declare const YEAR_ROWS = 7;
export declare class OwlMultiYearViewComponent<T> implements OnInit, AfterContentInit {
    private cdRef;
    private pickerIntl;
    private dateTimeAdapter;
    /**
     * The select mode of the picker;
     * */
    private _selectMode;
    get selectMode(): SelectMode;
    set selectMode(val: SelectMode);
    /** The currently selected date. */
    private _selected;
    get selected(): T | null;
    set selected(value: T | null);
    private _selecteds;
    get selecteds(): T[];
    set selecteds(values: T[]);
    private _pickerMoment;
    get pickerMoment(): T;
    set pickerMoment(value: T);
    /**
     * A function used to filter which dates are selectable
     * */
    private _dateFilter;
    get dateFilter(): (date: T) => boolean;
    set dateFilter(filter: (date: T) => boolean);
    /** The minimum selectable date. */
    private _minDate;
    get minDate(): T | null;
    set minDate(value: T | null);
    /** The maximum selectable date. */
    private _maxDate;
    get maxDate(): T | null;
    set maxDate(value: T | null);
    private _todayYear;
    get todayYear(): number;
    private _years;
    get years(): CalendarCell[][];
    private _selectedYears;
    get selectedYears(): number[];
    private initiated;
    get isInSingleMode(): boolean;
    get isInRangeMode(): boolean;
    get activeCell(): number;
    get tableHeader(): string;
    get prevButtonLabel(): string;
    get nextButtonLabel(): string;
    /**
     * Callback to invoke when a new month is selected
     * */
    readonly change: EventEmitter<T>;
    /**
     * Emits the selected year. This doesn't imply a change on the selected date
     * */
    readonly yearSelected: EventEmitter<T>;
    /** Emits when any date is activated. */
    readonly pickerMomentChange: EventEmitter<T>;
    /** Emits when use keyboard enter to select a calendar cell */
    readonly keyboardEnter: EventEmitter<any>;
    /** The body of calendar table */
    calendarBodyElm: OwlCalendarBodyComponent;
    get owlDTCalendarView(): boolean;
    get owlDTCalendarMultiYearView(): boolean;
    constructor(cdRef: ChangeDetectorRef, pickerIntl: OwlDateTimeIntl, dateTimeAdapter: DateTimeAdapter<T>);
    ngOnInit(): void;
    ngAfterContentInit(): void;
    /**
     * Handle a calendarCell selected
     */
    selectCalendarCell(cell: CalendarCell): void;
    private selectYear;
    /**
     * Generate the previous year list
     * */
    prevYearList(event: any): void;
    /**
     * Generate the next year list
     * */
    nextYearList(event: any): void;
    generateYearList(): void;
    /** Whether the previous period button is enabled. */
    previousEnabled(): boolean;
    /** Whether the next period button is enabled. */
    nextEnabled(): boolean;
    handleCalendarKeydown(event: KeyboardEvent): void;
    /**
     * Creates an CalendarCell for the given year.
     */
    private createYearCell;
    private setSelectedYears;
    /** Whether the given year is enabled. */
    private isYearEnabled;
    private isSameYearList;
    /**
     * Get a valid date object
     */
    private getValidDate;
    private focusActiveCell;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OwlMultiYearViewComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<OwlMultiYearViewComponent<any>, "owl-date-time-multi-year-view", never, {
    "selectMode": "selectMode";
    "selected": "selected";
    "selecteds": "selecteds";
    "pickerMoment": "pickerMoment";
    "dateFilter": "dateFilter";
    "minDate": "minDate";
    "maxDate": "maxDate";
}, {
    "change": "change";
    "yearSelected": "yearSelected";
    "pickerMomentChange": "pickerMomentChange";
    "keyboardEnter": "keyboardEnter";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItbXVsdGkteWVhci12aWV3LmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJjYWxlbmRhci1tdWx0aS15ZWFyLXZpZXcuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0dBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBjYWxlbmRhci1tdWx0aS15ZWFyLXZpZXcuY29tcG9uZW50XG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBFdmVudEVtaXR0ZXIsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1hZGFwdGVyLmNsYXNzJztcbmltcG9ydCB7IENhbGVuZGFyQ2VsbCwgT3dsQ2FsZW5kYXJCb2R5Q29tcG9uZW50IH0gZnJvbSAnLi9jYWxlbmRhci1ib2R5LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3RNb2RlIH0gZnJvbSAnLi9kYXRlLXRpbWUuY2xhc3MnO1xuaW1wb3J0IHsgT3dsRGF0ZVRpbWVJbnRsIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLWludGwuc2VydmljZSc7XG5leHBvcnQgZGVjbGFyZSBjb25zdCBZRUFSU19QRVJfUk9XID0gMztcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IFlFQVJfUk9XUyA9IDc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBPd2xNdWx0aVllYXJWaWV3Q29tcG9uZW50PFQ+IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIGNkUmVmO1xuICAgIHByaXZhdGUgcGlja2VySW50bDtcbiAgICBwcml2YXRlIGRhdGVUaW1lQWRhcHRlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0IG1vZGUgb2YgdGhlIHBpY2tlcjtcbiAgICAgKiAqL1xuICAgIHByaXZhdGUgX3NlbGVjdE1vZGU7XG4gICAgZ2V0IHNlbGVjdE1vZGUoKTogU2VsZWN0TW9kZTtcbiAgICBzZXQgc2VsZWN0TW9kZSh2YWw6IFNlbGVjdE1vZGUpO1xuICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ7XG4gICAgZ2V0IHNlbGVjdGVkKCk6IFQgfCBudWxsO1xuICAgIHNldCBzZWxlY3RlZCh2YWx1ZTogVCB8IG51bGwpO1xuICAgIHByaXZhdGUgX3NlbGVjdGVkcztcbiAgICBnZXQgc2VsZWN0ZWRzKCk6IFRbXTtcbiAgICBzZXQgc2VsZWN0ZWRzKHZhbHVlczogVFtdKTtcbiAgICBwcml2YXRlIF9waWNrZXJNb21lbnQ7XG4gICAgZ2V0IHBpY2tlck1vbWVudCgpOiBUO1xuICAgIHNldCBwaWNrZXJNb21lbnQodmFsdWU6IFQpO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdXNlZCB0byBmaWx0ZXIgd2hpY2ggZGF0ZXMgYXJlIHNlbGVjdGFibGVcbiAgICAgKiAqL1xuICAgIHByaXZhdGUgX2RhdGVGaWx0ZXI7XG4gICAgZ2V0IGRhdGVGaWx0ZXIoKTogKGRhdGU6IFQpID0+IGJvb2xlYW47XG4gICAgc2V0IGRhdGVGaWx0ZXIoZmlsdGVyOiAoZGF0ZTogVCkgPT4gYm9vbGVhbik7XG4gICAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgICBwcml2YXRlIF9taW5EYXRlO1xuICAgIGdldCBtaW5EYXRlKCk6IFQgfCBudWxsO1xuICAgIHNldCBtaW5EYXRlKHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgLyoqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgICBwcml2YXRlIF9tYXhEYXRlO1xuICAgIGdldCBtYXhEYXRlKCk6IFQgfCBudWxsO1xuICAgIHNldCBtYXhEYXRlKHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgcHJpdmF0ZSBfdG9kYXlZZWFyO1xuICAgIGdldCB0b2RheVllYXIoKTogbnVtYmVyO1xuICAgIHByaXZhdGUgX3llYXJzO1xuICAgIGdldCB5ZWFycygpOiBDYWxlbmRhckNlbGxbXVtdO1xuICAgIHByaXZhdGUgX3NlbGVjdGVkWWVhcnM7XG4gICAgZ2V0IHNlbGVjdGVkWWVhcnMoKTogbnVtYmVyW107XG4gICAgcHJpdmF0ZSBpbml0aWF0ZWQ7XG4gICAgZ2V0IGlzSW5TaW5nbGVNb2RlKCk6IGJvb2xlYW47XG4gICAgZ2V0IGlzSW5SYW5nZU1vZGUoKTogYm9vbGVhbjtcbiAgICBnZXQgYWN0aXZlQ2VsbCgpOiBudW1iZXI7XG4gICAgZ2V0IHRhYmxlSGVhZGVyKCk6IHN0cmluZztcbiAgICBnZXQgcHJldkJ1dHRvbkxhYmVsKCk6IHN0cmluZztcbiAgICBnZXQgbmV4dEJ1dHRvbkxhYmVsKCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhIG5ldyBtb250aCBpcyBzZWxlY3RlZFxuICAgICAqICovXG4gICAgcmVhZG9ubHkgY2hhbmdlOiBFdmVudEVtaXR0ZXI8VD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIHNlbGVjdGVkIHllYXIuIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZVxuICAgICAqICovXG4gICAgcmVhZG9ubHkgeWVhclNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8VD47XG4gICAgLyoqIEVtaXRzIHdoZW4gYW55IGRhdGUgaXMgYWN0aXZhdGVkLiAqL1xuICAgIHJlYWRvbmx5IHBpY2tlck1vbWVudENoYW5nZTogRXZlbnRFbWl0dGVyPFQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIHVzZSBrZXlib2FyZCBlbnRlciB0byBzZWxlY3QgYSBjYWxlbmRhciBjZWxsICovXG4gICAgcmVhZG9ubHkga2V5Ym9hcmRFbnRlcjogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqIFRoZSBib2R5IG9mIGNhbGVuZGFyIHRhYmxlICovXG4gICAgY2FsZW5kYXJCb2R5RWxtOiBPd2xDYWxlbmRhckJvZHlDb21wb25lbnQ7XG4gICAgZ2V0IG93bERUQ2FsZW5kYXJWaWV3KCk6IGJvb2xlYW47XG4gICAgZ2V0IG93bERUQ2FsZW5kYXJNdWx0aVllYXJWaWV3KCk6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwaWNrZXJJbnRsOiBPd2xEYXRlVGltZUludGwsIGRhdGVUaW1lQWRhcHRlcjogRGF0ZVRpbWVBZGFwdGVyPFQ+KTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGNhbGVuZGFyQ2VsbCBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNlbGVjdENhbGVuZGFyQ2VsbChjZWxsOiBDYWxlbmRhckNlbGwpOiB2b2lkO1xuICAgIHByaXZhdGUgc2VsZWN0WWVhcjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgcHJldmlvdXMgeWVhciBsaXN0XG4gICAgICogKi9cbiAgICBwcmV2WWVhckxpc3QoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIG5leHQgeWVhciBsaXN0XG4gICAgICogKi9cbiAgICBuZXh0WWVhckxpc3QoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgZ2VuZXJhdGVZZWFyTGlzdCgpOiB2b2lkO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwcmV2aW91cyBwZXJpb2QgYnV0dG9uIGlzIGVuYWJsZWQuICovXG4gICAgcHJldmlvdXNFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICAgIG5leHRFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgaGFuZGxlQ2FsZW5kYXJLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIENhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIHllYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVZZWFyQ2VsbDtcbiAgICBwcml2YXRlIHNldFNlbGVjdGVkWWVhcnM7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGdpdmVuIHllYXIgaXMgZW5hYmxlZC4gKi9cbiAgICBwcml2YXRlIGlzWWVhckVuYWJsZWQ7XG4gICAgcHJpdmF0ZSBpc1NhbWVZZWFyTGlzdDtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWxpZCBkYXRlIG9iamVjdFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0VmFsaWREYXRlO1xuICAgIHByaXZhdGUgZm9jdXNBY3RpdmVDZWxsO1xufVxuIl19