/**
 * date-time-inline.component
 */
import { ChangeDetectorRef, EventEmitter, OnInit } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { OwlDateTime, PickerMode, PickerType, SelectMode } from './date-time.class';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { OwlDateTimeFormats } from './adapter/date-time-format.class';
import { OwlDateTimeContainerComponent } from './date-time-picker-container.component';
import * as ɵngcc0 from '@angular/core';
export declare const OWL_DATETIME_VALUE_ACCESSOR: any;
export declare class OwlDateTimeInlineComponent<T> extends OwlDateTime<T> implements OnInit, ControlValueAccessor {
    protected changeDetector: ChangeDetectorRef;
    protected dateTimeAdapter: DateTimeAdapter<T>;
    protected dateTimeFormats: OwlDateTimeFormats;
    container: OwlDateTimeContainerComponent<T>;
    /**
     * Set the type of the dateTime picker
     *      'both' -- show both calendar and timer
     *      'calendar' -- show only calendar
     *      'timer' -- show only timer
     */
    private _pickerType;
    get pickerType(): PickerType;
    set pickerType(val: PickerType);
    private _disabled;
    get disabled(): boolean;
    set disabled(value: boolean);
    private _selectMode;
    get selectMode(): SelectMode;
    set selectMode(mode: SelectMode);
    /** The date to open the calendar to initially. */
    private _startAt;
    get startAt(): T | null;
    set startAt(date: T | null);
    private _dateTimeFilter;
    get dateTimeFilter(): (date: T | null) => boolean;
    set dateTimeFilter(filter: (date: T | null) => boolean);
    /** The minimum valid date. */
    private _min;
    get minDateTime(): T | null;
    set minDateTime(value: T | null);
    /** The maximum valid date. */
    private _max;
    get maxDateTime(): T | null;
    set maxDateTime(value: T | null);
    private _value;
    get value(): T | null;
    set value(value: T | null);
    private _values;
    get values(): T[];
    set values(values: T[]);
    /**
     * Emits selected year in multi-year view
     * This doesn't imply a change on the selected date.
     * */
    yearSelected: EventEmitter<T>;
    /**
     * Emits selected month in year view
     * This doesn't imply a change on the selected date.
     * */
    monthSelected: EventEmitter<T>;
    private _selected;
    get selected(): T | null;
    set selected(value: T | null);
    private _selecteds;
    get selecteds(): T[];
    set selecteds(values: T[]);
    get opened(): boolean;
    get pickerMode(): PickerMode;
    get isInSingleMode(): boolean;
    get isInRangeMode(): boolean;
    get owlDTInlineClass(): boolean;
    private onModelChange;
    private onModelTouched;
    constructor(changeDetector: ChangeDetectorRef, dateTimeAdapter: DateTimeAdapter<T>, dateTimeFormats: OwlDateTimeFormats);
    ngOnInit(): void;
    writeValue(value: any): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    select(date: T[] | T): void;
    /**
     * Emits the selected year in multi-year view
     * */
    selectYear(normalizedYear: T): void;
    /**
     * Emits selected month in year view
     * */
    selectMonth(normalizedMonth: T): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OwlDateTimeInlineComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<OwlDateTimeInlineComponent<any>, "owl-date-time-inline", never, {
    "pickerType": "pickerType";
    "disabled": "disabled";
    "selectMode": "selectMode";
    "startAt": "startAt";
    "dateTimeFilter": "owlDateTimeFilter";
    "minDateTime": "min";
    "maxDateTime": "max";
    "value": "value";
    "values": "values";
}, {
    "yearSelected": "yearSelected";
    "monthSelected": "monthSelected";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLWlubGluZS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZS10aW1lLWlubGluZS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdGQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGF0ZS10aW1lLWlubGluZS5jb21wb25lbnRcbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE93bERhdGVUaW1lLCBQaWNrZXJNb2RlLCBQaWNrZXJUeXBlLCBTZWxlY3RNb2RlIH0gZnJvbSAnLi9kYXRlLXRpbWUuY2xhc3MnO1xuaW1wb3J0IHsgRGF0ZVRpbWVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1hZGFwdGVyLmNsYXNzJztcbmltcG9ydCB7IE93bERhdGVUaW1lRm9ybWF0cyB9IGZyb20gJy4vYWRhcHRlci9kYXRlLXRpbWUtZm9ybWF0LmNsYXNzJztcbmltcG9ydCB7IE93bERhdGVUaW1lQ29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgT1dMX0RBVEVUSU1FX1ZBTFVFX0FDQ0VTU09SOiBhbnk7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBPd2xEYXRlVGltZUlubGluZUNvbXBvbmVudDxUPiBleHRlbmRzIE93bERhdGVUaW1lPFQ+IGltcGxlbWVudHMgT25Jbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgcHJvdGVjdGVkIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBwcm90ZWN0ZWQgZGF0ZVRpbWVBZGFwdGVyOiBEYXRlVGltZUFkYXB0ZXI8VD47XG4gICAgcHJvdGVjdGVkIGRhdGVUaW1lRm9ybWF0czogT3dsRGF0ZVRpbWVGb3JtYXRzO1xuICAgIGNvbnRhaW5lcjogT3dsRGF0ZVRpbWVDb250YWluZXJDb21wb25lbnQ8VD47XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0eXBlIG9mIHRoZSBkYXRlVGltZSBwaWNrZXJcbiAgICAgKiAgICAgICdib3RoJyAtLSBzaG93IGJvdGggY2FsZW5kYXIgYW5kIHRpbWVyXG4gICAgICogICAgICAnY2FsZW5kYXInIC0tIHNob3cgb25seSBjYWxlbmRhclxuICAgICAqICAgICAgJ3RpbWVyJyAtLSBzaG93IG9ubHkgdGltZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9waWNrZXJUeXBlO1xuICAgIGdldCBwaWNrZXJUeXBlKCk6IFBpY2tlclR5cGU7XG4gICAgc2V0IHBpY2tlclR5cGUodmFsOiBQaWNrZXJUeXBlKTtcbiAgICBwcml2YXRlIF9kaXNhYmxlZDtcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX3NlbGVjdE1vZGU7XG4gICAgZ2V0IHNlbGVjdE1vZGUoKTogU2VsZWN0TW9kZTtcbiAgICBzZXQgc2VsZWN0TW9kZShtb2RlOiBTZWxlY3RNb2RlKTtcbiAgICAvKiogVGhlIGRhdGUgdG8gb3BlbiB0aGUgY2FsZW5kYXIgdG8gaW5pdGlhbGx5LiAqL1xuICAgIHByaXZhdGUgX3N0YXJ0QXQ7XG4gICAgZ2V0IHN0YXJ0QXQoKTogVCB8IG51bGw7XG4gICAgc2V0IHN0YXJ0QXQoZGF0ZTogVCB8IG51bGwpO1xuICAgIHByaXZhdGUgX2RhdGVUaW1lRmlsdGVyO1xuICAgIGdldCBkYXRlVGltZUZpbHRlcigpOiAoZGF0ZTogVCB8IG51bGwpID0+IGJvb2xlYW47XG4gICAgc2V0IGRhdGVUaW1lRmlsdGVyKGZpbHRlcjogKGRhdGU6IFQgfCBudWxsKSA9PiBib29sZWFuKTtcbiAgICAvKiogVGhlIG1pbmltdW0gdmFsaWQgZGF0ZS4gKi9cbiAgICBwcml2YXRlIF9taW47XG4gICAgZ2V0IG1pbkRhdGVUaW1lKCk6IFQgfCBudWxsO1xuICAgIHNldCBtaW5EYXRlVGltZSh2YWx1ZTogVCB8IG51bGwpO1xuICAgIC8qKiBUaGUgbWF4aW11bSB2YWxpZCBkYXRlLiAqL1xuICAgIHByaXZhdGUgX21heDtcbiAgICBnZXQgbWF4RGF0ZVRpbWUoKTogVCB8IG51bGw7XG4gICAgc2V0IG1heERhdGVUaW1lKHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgcHJpdmF0ZSBfdmFsdWU7XG4gICAgZ2V0IHZhbHVlKCk6IFQgfCBudWxsO1xuICAgIHNldCB2YWx1ZSh2YWx1ZTogVCB8IG51bGwpO1xuICAgIHByaXZhdGUgX3ZhbHVlcztcbiAgICBnZXQgdmFsdWVzKCk6IFRbXTtcbiAgICBzZXQgdmFsdWVzKHZhbHVlczogVFtdKTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBzZWxlY3RlZCB5ZWFyIGluIG11bHRpLXllYXIgdmlld1xuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiAqL1xuICAgIHllYXJTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFQ+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHNlbGVjdGVkIG1vbnRoIGluIHllYXIgdmlld1xuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiAqL1xuICAgIG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxUPjtcbiAgICBwcml2YXRlIF9zZWxlY3RlZDtcbiAgICBnZXQgc2VsZWN0ZWQoKTogVCB8IG51bGw7XG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRzO1xuICAgIGdldCBzZWxlY3RlZHMoKTogVFtdO1xuICAgIHNldCBzZWxlY3RlZHModmFsdWVzOiBUW10pO1xuICAgIGdldCBvcGVuZWQoKTogYm9vbGVhbjtcbiAgICBnZXQgcGlja2VyTW9kZSgpOiBQaWNrZXJNb2RlO1xuICAgIGdldCBpc0luU2luZ2xlTW9kZSgpOiBib29sZWFuO1xuICAgIGdldCBpc0luUmFuZ2VNb2RlKCk6IGJvb2xlYW47XG4gICAgZ2V0IG93bERUSW5saW5lQ2xhc3MoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIG9uTW9kZWxDaGFuZ2U7XG4gICAgcHJpdmF0ZSBvbk1vZGVsVG91Y2hlZDtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGRhdGVUaW1lQWRhcHRlcjogRGF0ZVRpbWVBZGFwdGVyPFQ+LCBkYXRlVGltZUZvcm1hdHM6IE93bERhdGVUaW1lRm9ybWF0cyk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICBzZWxlY3QoZGF0ZTogVFtdIHwgVCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIHNlbGVjdGVkIHllYXIgaW4gbXVsdGkteWVhciB2aWV3XG4gICAgICogKi9cbiAgICBzZWxlY3RZZWFyKG5vcm1hbGl6ZWRZZWFyOiBUKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBzZWxlY3RlZCBtb250aCBpbiB5ZWFyIHZpZXdcbiAgICAgKiAqL1xuICAgIHNlbGVjdE1vbnRoKG5vcm1hbGl6ZWRNb250aDogVCk6IHZvaWQ7XG59XG4iXX0=