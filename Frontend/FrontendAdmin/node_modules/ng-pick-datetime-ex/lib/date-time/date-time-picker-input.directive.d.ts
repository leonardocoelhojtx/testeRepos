/**
 * date-time-picker-input.directive
 */
import { AfterContentInit, ElementRef, EventEmitter, OnDestroy, OnInit, Renderer2 } from '@angular/core';
import { AbstractControl, ControlValueAccessor, Validator } from '@angular/forms';
import { OwlDateTimeComponent } from './date-time-picker.component';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { OwlDateTimeFormats } from './adapter/date-time-format.class';
import { SelectMode } from './date-time.class';
import * as ɵngcc0 from '@angular/core';
export declare const OWL_DATETIME_VALUE_ACCESSOR: any;
export declare const OWL_DATETIME_VALIDATORS: any;
export declare class OwlDateTimeInputDirective<T> implements OnInit, AfterContentInit, OnDestroy, ControlValueAccessor, Validator {
    private elmRef;
    private renderer;
    private dateTimeAdapter;
    private dateTimeFormats;
    /**
     * The date time picker that this input is associated with.
     * */
    set owlDateTime(value: OwlDateTimeComponent<T>);
    /**
     * A function to filter date time
     */
    set owlDateTimeFilter(filter: (date: T | null) => boolean);
    private _dateTimeFilter;
    get dateTimeFilter(): (date: T) => boolean;
    /** Whether the date time picker's input is disabled. */
    private _disabled;
    get disabled(): boolean;
    set disabled(value: boolean);
    /** The minimum valid date. */
    private _min;
    get min(): T | null;
    set min(value: T | null);
    /** The maximum valid date. */
    private _max;
    get max(): T | null;
    set max(value: T | null);
    /**
     * The picker's select mode
     */
    private _selectMode;
    get selectMode(): SelectMode;
    set selectMode(mode: SelectMode);
    /**
     * The character to separate the 'from' and 'to' in input value
     */
    rangeSeparator: string;
    private _value;
    get value(): T | null;
    set value(value: T | null);
    private _values;
    get values(): T[];
    set values(values: T[]);
    /**
     * Callback to invoke when `change` event is fired on this `<input>`
     * */
    dateTimeChange: EventEmitter<any>;
    /**
     * Callback to invoke when an `input` event is fired on this `<input>`.
     * */
    dateTimeInput: EventEmitter<any>;
    get elementRef(): ElementRef;
    get isInSingleMode(): boolean;
    get isInRangeMode(): boolean;
    /** The date-time-picker that this input is associated with. */
    dtPicker: OwlDateTimeComponent<T>;
    private dtPickerSub;
    private localeSub;
    private lastValueValid;
    private onModelChange;
    private onModelTouched;
    private validatorOnChange;
    /** The form control validator for whether the input parses. */
    private parseValidator;
    /** The form control validator for the min date. */
    private minValidator;
    /** The form control validator for the max date. */
    private maxValidator;
    /** The form control validator for the date filter. */
    private filterValidator;
    /**
     * The form control validator for the range.
     * Check whether the 'before' value is before the 'to' value
     * */
    private rangeValidator;
    /** The combined form control validator for this input. */
    private validator;
    /** Emits when the value changes (either due to user input or programmatic change). */
    valueChange: EventEmitter<T | T[]>;
    /** Emits when the disabled state has changed */
    disabledChange: EventEmitter<boolean>;
    get owlDateTimeInputAriaHaspopup(): boolean;
    get owlDateTimeInputAriaOwns(): string;
    get minIso8601(): string;
    get maxIso8601(): string;
    get owlDateTimeInputDisabled(): boolean;
    constructor(elmRef: ElementRef, renderer: Renderer2, dateTimeAdapter: DateTimeAdapter<T>, dateTimeFormats: OwlDateTimeFormats);
    ngOnInit(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    writeValue(value: any): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    validate(c: AbstractControl): {
        [key: string]: any;
    };
    registerOnValidatorChange(fn: () => void): void;
    /**
     * Open the picker when user hold alt + DOWN_ARROW
     * */
    handleKeydownOnHost(event: KeyboardEvent): void;
    handleBlurOnHost(event: Event): void;
    handleInputOnHost(event: any): void;
    handleChangeOnHost(event: any): void;
    /**
     * Set the native input property 'value'
     */
    formatNativeInputValue(): void;
    /**
     * Register the relationship between this input and its picker component
     */
    private registerDateTimePicker;
    /**
     * Convert a given obj to a valid date object
     */
    private getValidDate;
    /**
     * Convert a time string to a date-time string
     * When pickerType is 'timer', the value in the picker's input is a time string.
     * The dateTimeAdapter parse fn could not parse a time string to a Date Object.
     * Therefore we need this fn to convert a time string to a date-time string.
     */
    private convertTimeStringToDateTimeString;
    /**
     * Handle input change in single mode
     */
    private changeInputInSingleMode;
    /**
     * Handle input change in rangeFrom or rangeTo mode
     */
    private changeInputInRangeFromToMode;
    /**
     * Handle input change in range mode
     */
    private changeInputInRangeMode;
    /**
     * Check if the two value is the same
     */
    private isSameValue;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OwlDateTimeInputDirective<any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<OwlDateTimeInputDirective<any>, "input[owlDateTime]", ["owlDateTimeInput"], {
    "rangeSeparator": "rangeSeparator";
    "value": "value";
    "owlDateTime": "owlDateTime";
    "owlDateTimeFilter": "owlDateTimeFilter";
    "_disabled": "_disabled";
    "min": "min";
    "max": "max";
    "selectMode": "selectMode";
    "values": "values";
}, {
    "dateTimeChange": "dateTimeChange";
    "dateTimeInput": "dateTimeInput";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLXBpY2tlci1pbnB1dC5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZS10aW1lLXBpY2tlci1pbnB1dC5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOElBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkYXRlLXRpbWUtcGlja2VyLWlucHV0LmRpcmVjdGl2ZVxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25Jbml0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE93bERhdGVUaW1lQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXRlVGltZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXIvZGF0ZS10aW1lLWFkYXB0ZXIuY2xhc3MnO1xuaW1wb3J0IHsgT3dsRGF0ZVRpbWVGb3JtYXRzIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1mb3JtYXQuY2xhc3MnO1xuaW1wb3J0IHsgU2VsZWN0TW9kZSB9IGZyb20gJy4vZGF0ZS10aW1lLmNsYXNzJztcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE9XTF9EQVRFVElNRV9WQUxVRV9BQ0NFU1NPUjogYW55O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgT1dMX0RBVEVUSU1FX1ZBTElEQVRPUlM6IGFueTtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE93bERhdGVUaW1lSW5wdXREaXJlY3RpdmU8VD4gaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG4gICAgcHJpdmF0ZSBlbG1SZWY7XG4gICAgcHJpdmF0ZSByZW5kZXJlcjtcbiAgICBwcml2YXRlIGRhdGVUaW1lQWRhcHRlcjtcbiAgICBwcml2YXRlIGRhdGVUaW1lRm9ybWF0cztcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSB0aW1lIHBpY2tlciB0aGF0IHRoaXMgaW5wdXQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAqICovXG4gICAgc2V0IG93bERhdGVUaW1lKHZhbHVlOiBPd2xEYXRlVGltZUNvbXBvbmVudDxUPik7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBmaWx0ZXIgZGF0ZSB0aW1lXG4gICAgICovXG4gICAgc2V0IG93bERhdGVUaW1lRmlsdGVyKGZpbHRlcjogKGRhdGU6IFQgfCBudWxsKSA9PiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9kYXRlVGltZUZpbHRlcjtcbiAgICBnZXQgZGF0ZVRpbWVGaWx0ZXIoKTogKGRhdGU6IFQpID0+IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgdGhlIGRhdGUgdGltZSBwaWNrZXIncyBpbnB1dCBpcyBkaXNhYmxlZC4gKi9cbiAgICBwcml2YXRlIF9kaXNhYmxlZDtcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKiBUaGUgbWluaW11bSB2YWxpZCBkYXRlLiAqL1xuICAgIHByaXZhdGUgX21pbjtcbiAgICBnZXQgbWluKCk6IFQgfCBudWxsO1xuICAgIHNldCBtaW4odmFsdWU6IFQgfCBudWxsKTtcbiAgICAvKiogVGhlIG1heGltdW0gdmFsaWQgZGF0ZS4gKi9cbiAgICBwcml2YXRlIF9tYXg7XG4gICAgZ2V0IG1heCgpOiBUIHwgbnVsbDtcbiAgICBzZXQgbWF4KHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogVGhlIHBpY2tlcidzIHNlbGVjdCBtb2RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2VsZWN0TW9kZTtcbiAgICBnZXQgc2VsZWN0TW9kZSgpOiBTZWxlY3RNb2RlO1xuICAgIHNldCBzZWxlY3RNb2RlKG1vZGU6IFNlbGVjdE1vZGUpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGFyYWN0ZXIgdG8gc2VwYXJhdGUgdGhlICdmcm9tJyBhbmQgJ3RvJyBpbiBpbnB1dCB2YWx1ZVxuICAgICAqL1xuICAgIHJhbmdlU2VwYXJhdG9yOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfdmFsdWU7XG4gICAgZ2V0IHZhbHVlKCk6IFQgfCBudWxsO1xuICAgIHNldCB2YWx1ZSh2YWx1ZTogVCB8IG51bGwpO1xuICAgIHByaXZhdGUgX3ZhbHVlcztcbiAgICBnZXQgdmFsdWVzKCk6IFRbXTtcbiAgICBzZXQgdmFsdWVzKHZhbHVlczogVFtdKTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBgY2hhbmdlYCBldmVudCBpcyBmaXJlZCBvbiB0aGlzIGA8aW5wdXQ+YFxuICAgICAqICovXG4gICAgZGF0ZVRpbWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGBpbnB1dGAgZXZlbnQgaXMgZmlyZWQgb24gdGhpcyBgPGlucHV0PmAuXG4gICAgICogKi9cbiAgICBkYXRlVGltZUlucHV0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBnZXQgZWxlbWVudFJlZigpOiBFbGVtZW50UmVmO1xuICAgIGdldCBpc0luU2luZ2xlTW9kZSgpOiBib29sZWFuO1xuICAgIGdldCBpc0luUmFuZ2VNb2RlKCk6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBkYXRlLXRpbWUtcGlja2VyIHRoYXQgdGhpcyBpbnB1dCBpcyBhc3NvY2lhdGVkIHdpdGguICovXG4gICAgZHRQaWNrZXI6IE93bERhdGVUaW1lQ29tcG9uZW50PFQ+O1xuICAgIHByaXZhdGUgZHRQaWNrZXJTdWI7XG4gICAgcHJpdmF0ZSBsb2NhbGVTdWI7XG4gICAgcHJpdmF0ZSBsYXN0VmFsdWVWYWxpZDtcbiAgICBwcml2YXRlIG9uTW9kZWxDaGFuZ2U7XG4gICAgcHJpdmF0ZSBvbk1vZGVsVG91Y2hlZDtcbiAgICBwcml2YXRlIHZhbGlkYXRvck9uQ2hhbmdlO1xuICAgIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3Igd2hldGhlciB0aGUgaW5wdXQgcGFyc2VzLiAqL1xuICAgIHByaXZhdGUgcGFyc2VWYWxpZGF0b3I7XG4gICAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWluIGRhdGUuICovXG4gICAgcHJpdmF0ZSBtaW5WYWxpZGF0b3I7XG4gICAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWF4IGRhdGUuICovXG4gICAgcHJpdmF0ZSBtYXhWYWxpZGF0b3I7XG4gICAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgZGF0ZSBmaWx0ZXIuICovXG4gICAgcHJpdmF0ZSBmaWx0ZXJWYWxpZGF0b3I7XG4gICAgLyoqXG4gICAgICogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSByYW5nZS5cbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSAnYmVmb3JlJyB2YWx1ZSBpcyBiZWZvcmUgdGhlICd0bycgdmFsdWVcbiAgICAgKiAqL1xuICAgIHByaXZhdGUgcmFuZ2VWYWxpZGF0b3I7XG4gICAgLyoqIFRoZSBjb21iaW5lZCBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGlzIGlucHV0LiAqL1xuICAgIHByaXZhdGUgdmFsaWRhdG9yO1xuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChlaXRoZXIgZHVlIHRvIHVzZXIgaW5wdXQgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZSkuICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUIHwgVFtdPjtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgZGlzYWJsZWQgc3RhdGUgaGFzIGNoYW5nZWQgKi9cbiAgICBkaXNhYmxlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuICAgIGdldCBvd2xEYXRlVGltZUlucHV0QXJpYUhhc3BvcHVwKCk6IGJvb2xlYW47XG4gICAgZ2V0IG93bERhdGVUaW1lSW5wdXRBcmlhT3ducygpOiBzdHJpbmc7XG4gICAgZ2V0IG1pbklzbzg2MDEoKTogc3RyaW5nO1xuICAgIGdldCBtYXhJc284NjAxKCk6IHN0cmluZztcbiAgICBnZXQgb3dsRGF0ZVRpbWVJbnB1dERpc2FibGVkKCk6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoZWxtUmVmOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIyLCBkYXRlVGltZUFkYXB0ZXI6IERhdGVUaW1lQWRhcHRlcjxUPiwgZGF0ZVRpbWVGb3JtYXRzOiBPd2xEYXRlVGltZUZvcm1hdHMpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgICB9O1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIHBpY2tlciB3aGVuIHVzZXIgaG9sZCBhbHQgKyBET1dOX0FSUk9XXG4gICAgICogKi9cbiAgICBoYW5kbGVLZXlkb3duT25Ib3N0KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICBoYW5kbGVCbHVyT25Ib3N0KGV2ZW50OiBFdmVudCk6IHZvaWQ7XG4gICAgaGFuZGxlSW5wdXRPbkhvc3QoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgaGFuZGxlQ2hhbmdlT25Ib3N0KGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbmF0aXZlIGlucHV0IHByb3BlcnR5ICd2YWx1ZSdcbiAgICAgKi9cbiAgICBmb3JtYXROYXRpdmVJbnB1dFZhbHVlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoaXMgaW5wdXQgYW5kIGl0cyBwaWNrZXIgY29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RlckRhdGVUaW1lUGlja2VyO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBnaXZlbiBvYmogdG8gYSB2YWxpZCBkYXRlIG9iamVjdFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0VmFsaWREYXRlO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB0aW1lIHN0cmluZyB0byBhIGRhdGUtdGltZSBzdHJpbmdcbiAgICAgKiBXaGVuIHBpY2tlclR5cGUgaXMgJ3RpbWVyJywgdGhlIHZhbHVlIGluIHRoZSBwaWNrZXIncyBpbnB1dCBpcyBhIHRpbWUgc3RyaW5nLlxuICAgICAqIFRoZSBkYXRlVGltZUFkYXB0ZXIgcGFyc2UgZm4gY291bGQgbm90IHBhcnNlIGEgdGltZSBzdHJpbmcgdG8gYSBEYXRlIE9iamVjdC5cbiAgICAgKiBUaGVyZWZvcmUgd2UgbmVlZCB0aGlzIGZuIHRvIGNvbnZlcnQgYSB0aW1lIHN0cmluZyB0byBhIGRhdGUtdGltZSBzdHJpbmcuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb252ZXJ0VGltZVN0cmluZ1RvRGF0ZVRpbWVTdHJpbmc7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGlucHV0IGNoYW5nZSBpbiBzaW5nbGUgbW9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgY2hhbmdlSW5wdXRJblNpbmdsZU1vZGU7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGlucHV0IGNoYW5nZSBpbiByYW5nZUZyb20gb3IgcmFuZ2VUbyBtb2RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBjaGFuZ2VJbnB1dEluUmFuZ2VGcm9tVG9Nb2RlO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbnB1dCBjaGFuZ2UgaW4gcmFuZ2UgbW9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgY2hhbmdlSW5wdXRJblJhbmdlTW9kZTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgdHdvIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1NhbWVWYWx1ZTtcbn1cbiJdfQ==