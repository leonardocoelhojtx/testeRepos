/**
 * date-time-picker.component
 */
import { ChangeDetectorRef, EventEmitter, InjectionToken, NgZone, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { BlockScrollStrategy, Overlay, ScrollStrategy } from '@angular/cdk/overlay';
import { OwlDateTimeInputDirective } from './date-time-picker-input.directive';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { OwlDateTimeFormats } from './adapter/date-time-format.class';
import { OwlDateTime, PickerMode, PickerType, SelectMode } from './date-time.class';
import { OwlDialogService } from '../dialog/dialog.service';
/** Injection token that determines the scroll handling while the dtPicker is open. */
import * as ɵngcc0 from '@angular/core';
export declare const OWL_DTPICKER_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;
/** @docs-private */
export declare function OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => BlockScrollStrategy;
/** @docs-private */
export declare const OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY;
};
export declare class OwlDateTimeComponent<T> extends OwlDateTime<T> implements OnInit, OnDestroy {
    private overlay;
    private viewContainerRef;
    private dialogService;
    private ngZone;
    protected changeDetector: ChangeDetectorRef;
    protected dateTimeAdapter: DateTimeAdapter<T>;
    protected dateTimeFormats: OwlDateTimeFormats;
    private document;
    /** Custom class for the picker backdrop. */
    backdropClass: string | string[];
    /** Custom class for the picker overlay pane. */
    panelClass: string | string[];
    /** The date to open the calendar to initially. */
    private _startAt;
    get startAt(): T | null;
    set startAt(date: T | null);
    /**
     * Set the type of the dateTime picker
     *      'both' -- show both calendar and timer
     *      'calendar' -- show only calendar
     *      'timer' -- show only timer
     */
    private _pickerType;
    get pickerType(): PickerType;
    set pickerType(val: PickerType);
    /**
     * Whether the picker open as a dialog
     */
    _pickerMode: PickerMode;
    get pickerMode(): PickerMode;
    set pickerMode(mode: PickerMode);
    /** Whether the date time picker should be disabled. */
    private _disabled;
    get disabled(): boolean;
    set disabled(value: boolean);
    /** Whether the calendar is open. */
    private _opened;
    get opened(): boolean;
    set opened(val: boolean);
    /**
     * The scroll strategy when the picker is open
     * Learn more this from https://material.angular.io/cdk/overlay/overview#scroll-strategies
     * */
    scrollStrategy: ScrollStrategy;
    /**
     * Callback when the picker is closed
     * */
    afterPickerClosed: EventEmitter<any>;
    /**
     * Callback when the picker is open
     * */
    afterPickerOpen: EventEmitter<any>;
    /**
     * Emits selected year in multi-year view
     * This doesn't imply a change on the selected date.
     * */
    yearSelected: EventEmitter<T>;
    /**
     * Emits selected month in year view
     * This doesn't imply a change on the selected date.
     * */
    monthSelected: EventEmitter<T>;
    /**
     * Emit when the selected value has been confirmed
     * */
    confirmSelectedChange: EventEmitter<T | T[]>;
    /**
     * Emits when the date time picker is disabled.
     * */
    disabledChange: EventEmitter<boolean>;
    private pickerContainerPortal;
    private pickerContainer;
    private popupRef;
    private dialogRef;
    private dtInputSub;
    private hidePickerStreamSub;
    private confirmSelectedStreamSub;
    private pickerOpenedStreamSub;
    /** The element that was focused before the date time picker was opened. */
    private focusedElementBeforeOpen;
    private _dtInput;
    get dtInput(): OwlDateTimeInputDirective<T>;
    private _selected;
    get selected(): T | null;
    set selected(value: T | null);
    private _selecteds;
    get selecteds(): T[];
    set selecteds(values: T[]);
    /** The minimum selectable date. */
    get minDateTime(): T | null;
    /** The maximum selectable date. */
    get maxDateTime(): T | null;
    get dateTimeFilter(): (date: T | null) => boolean;
    get selectMode(): SelectMode;
    get isInSingleMode(): boolean;
    get isInRangeMode(): boolean;
    private defaultScrollStrategy;
    constructor(overlay: Overlay, viewContainerRef: ViewContainerRef, dialogService: OwlDialogService, ngZone: NgZone, changeDetector: ChangeDetectorRef, dateTimeAdapter: DateTimeAdapter<T>, defaultScrollStrategy: any, dateTimeFormats: OwlDateTimeFormats, document: any);
    ngOnInit(): void;
    ngOnDestroy(): void;
    registerInput(input: OwlDateTimeInputDirective<T>): void;
    open(): void;
    /**
     * Selects the given date
     */
    select(date: T[] | T): void;
    /**
     * Emits the selected year in multi-year view
     * */
    selectYear(normalizedYear: T): void;
    /**
     * Emits selected month in year view
     * */
    selectMonth(normalizedMonth: T): void;
    /**
     * Hide the picker
     */
    close(): void;
    /**
     * Confirm the selected value
     */
    confirmSelect(event?: any): void;
    /**
     * Open the picker as a dialog
     */
    private openAsDialog;
    /**
     * Open the picker as popup
     */
    private openAsPopup;
    private createPopup;
    /**
     * Create the popup PositionStrategy.
     * */
    private createPopupPositionStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OwlDateTimeComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<OwlDateTimeComponent<any>, "owl-date-time", ["owlDateTime"], {
    "backdropClass": "backdropClass";
    "panelClass": "panelClass";
    "startAt": "startAt";
    "pickerType": "pickerType";
    "pickerMode": "pickerMode";
    "disabled": "disabled";
    "opened": "opened";
    "scrollStrategy": "scrollStrategy";
}, {
    "afterPickerClosed": "afterPickerClosed";
    "afterPickerOpen": "afterPickerOpen";
    "yearSelected": "yearSelected";
    "monthSelected": "monthSelected";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUpBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkYXRlLXRpbWUtcGlja2VyLmNvbXBvbmVudFxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3Rpb25Ub2tlbiwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmxvY2tTY3JvbGxTdHJhdGVneSwgT3ZlcmxheSwgU2Nyb2xsU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBPd2xEYXRlVGltZUlucHV0RGlyZWN0aXZlIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLWlucHV0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEYXRlVGltZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXIvZGF0ZS10aW1lLWFkYXB0ZXIuY2xhc3MnO1xuaW1wb3J0IHsgT3dsRGF0ZVRpbWVGb3JtYXRzIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1mb3JtYXQuY2xhc3MnO1xuaW1wb3J0IHsgT3dsRGF0ZVRpbWUsIFBpY2tlck1vZGUsIFBpY2tlclR5cGUsIFNlbGVjdE1vZGUgfSBmcm9tICcuL2RhdGUtdGltZS5jbGFzcyc7XG5pbXBvcnQgeyBPd2xEaWFsb2dTZXJ2aWNlIH0gZnJvbSAnLi4vZGlhbG9nL2RpYWxvZy5zZXJ2aWNlJztcbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBkZXRlcm1pbmVzIHRoZSBzY3JvbGwgaGFuZGxpbmcgd2hpbGUgdGhlIGR0UGlja2VyIGlzIG9wZW4uICovXG5leHBvcnQgZGVjbGFyZSBjb25zdCBPV0xfRFRQSUNLRVJfU0NST0xMX1NUUkFURUdZOiBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT47XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gT1dMX0RUUElDS0VSX1NDUk9MTF9TVFJBVEVHWV9QUk9WSURFUl9GQUNUT1JZKG92ZXJsYXk6IE92ZXJsYXkpOiAoKSA9PiBCbG9ja1Njcm9sbFN0cmF0ZWd5O1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE9XTF9EVFBJQ0tFUl9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVI6IHtcbiAgICBwcm92aWRlOiBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT47XG4gICAgZGVwczogKHR5cGVvZiBPdmVybGF5KVtdO1xuICAgIHVzZUZhY3Rvcnk6IHR5cGVvZiBPV0xfRFRQSUNLRVJfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlk7XG59O1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgT3dsRGF0ZVRpbWVDb21wb25lbnQ8VD4gZXh0ZW5kcyBPd2xEYXRlVGltZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIG92ZXJsYXk7XG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmO1xuICAgIHByaXZhdGUgZGlhbG9nU2VydmljZTtcbiAgICBwcml2YXRlIG5nWm9uZTtcbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIHByb3RlY3RlZCBkYXRlVGltZUFkYXB0ZXI6IERhdGVUaW1lQWRhcHRlcjxUPjtcbiAgICBwcm90ZWN0ZWQgZGF0ZVRpbWVGb3JtYXRzOiBPd2xEYXRlVGltZUZvcm1hdHM7XG4gICAgcHJpdmF0ZSBkb2N1bWVudDtcbiAgICAvKiogQ3VzdG9tIGNsYXNzIGZvciB0aGUgcGlja2VyIGJhY2tkcm9wLiAqL1xuICAgIGJhY2tkcm9wQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIC8qKiBDdXN0b20gY2xhc3MgZm9yIHRoZSBwaWNrZXIgb3ZlcmxheSBwYW5lLiAqL1xuICAgIHBhbmVsQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIC8qKiBUaGUgZGF0ZSB0byBvcGVuIHRoZSBjYWxlbmRhciB0byBpbml0aWFsbHkuICovXG4gICAgcHJpdmF0ZSBfc3RhcnRBdDtcbiAgICBnZXQgc3RhcnRBdCgpOiBUIHwgbnVsbDtcbiAgICBzZXQgc3RhcnRBdChkYXRlOiBUIHwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0eXBlIG9mIHRoZSBkYXRlVGltZSBwaWNrZXJcbiAgICAgKiAgICAgICdib3RoJyAtLSBzaG93IGJvdGggY2FsZW5kYXIgYW5kIHRpbWVyXG4gICAgICogICAgICAnY2FsZW5kYXInIC0tIHNob3cgb25seSBjYWxlbmRhclxuICAgICAqICAgICAgJ3RpbWVyJyAtLSBzaG93IG9ubHkgdGltZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9waWNrZXJUeXBlO1xuICAgIGdldCBwaWNrZXJUeXBlKCk6IFBpY2tlclR5cGU7XG4gICAgc2V0IHBpY2tlclR5cGUodmFsOiBQaWNrZXJUeXBlKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwaWNrZXIgb3BlbiBhcyBhIGRpYWxvZ1xuICAgICAqL1xuICAgIF9waWNrZXJNb2RlOiBQaWNrZXJNb2RlO1xuICAgIGdldCBwaWNrZXJNb2RlKCk6IFBpY2tlck1vZGU7XG4gICAgc2V0IHBpY2tlck1vZGUobW9kZTogUGlja2VyTW9kZSk7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGRhdGUgdGltZSBwaWNrZXIgc2hvdWxkIGJlIGRpc2FibGVkLiAqL1xuICAgIHByaXZhdGUgX2Rpc2FibGVkO1xuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIG9wZW4uICovXG4gICAgcHJpdmF0ZSBfb3BlbmVkO1xuICAgIGdldCBvcGVuZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgb3BlbmVkKHZhbDogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogVGhlIHNjcm9sbCBzdHJhdGVneSB3aGVuIHRoZSBwaWNrZXIgaXMgb3BlblxuICAgICAqIExlYXJuIG1vcmUgdGhpcyBmcm9tIGh0dHBzOi8vbWF0ZXJpYWwuYW5ndWxhci5pby9jZGsvb3ZlcmxheS9vdmVydmlldyNzY3JvbGwtc3RyYXRlZ2llc1xuICAgICAqICovXG4gICAgc2Nyb2xsU3RyYXRlZ3k6IFNjcm9sbFN0cmF0ZWd5O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdoZW4gdGhlIHBpY2tlciBpcyBjbG9zZWRcbiAgICAgKiAqL1xuICAgIGFmdGVyUGlja2VyQ2xvc2VkOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aGVuIHRoZSBwaWNrZXIgaXMgb3BlblxuICAgICAqICovXG4gICAgYWZ0ZXJQaWNrZXJPcGVuOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBzZWxlY3RlZCB5ZWFyIGluIG11bHRpLXllYXIgdmlld1xuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiAqL1xuICAgIHllYXJTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFQ+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHNlbGVjdGVkIG1vbnRoIGluIHllYXIgdmlld1xuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiAqL1xuICAgIG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxUPjtcbiAgICAvKipcbiAgICAgKiBFbWl0IHdoZW4gdGhlIHNlbGVjdGVkIHZhbHVlIGhhcyBiZWVuIGNvbmZpcm1lZFxuICAgICAqICovXG4gICAgY29uZmlybVNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8VCB8IFRbXT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgZGF0ZSB0aW1lIHBpY2tlciBpcyBkaXNhYmxlZC5cbiAgICAgKiAqL1xuICAgIGRpc2FibGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgcHJpdmF0ZSBwaWNrZXJDb250YWluZXJQb3J0YWw7XG4gICAgcHJpdmF0ZSBwaWNrZXJDb250YWluZXI7XG4gICAgcHJpdmF0ZSBwb3B1cFJlZjtcbiAgICBwcml2YXRlIGRpYWxvZ1JlZjtcbiAgICBwcml2YXRlIGR0SW5wdXRTdWI7XG4gICAgcHJpdmF0ZSBoaWRlUGlja2VyU3RyZWFtU3ViO1xuICAgIHByaXZhdGUgY29uZmlybVNlbGVjdGVkU3RyZWFtU3ViO1xuICAgIHByaXZhdGUgcGlja2VyT3BlbmVkU3RyZWFtU3ViO1xuICAgIC8qKiBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgZGF0ZSB0aW1lIHBpY2tlciB3YXMgb3BlbmVkLiAqL1xuICAgIHByaXZhdGUgZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuO1xuICAgIHByaXZhdGUgX2R0SW5wdXQ7XG4gICAgZ2V0IGR0SW5wdXQoKTogT3dsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZTxUPjtcbiAgICBwcml2YXRlIF9zZWxlY3RlZDtcbiAgICBnZXQgc2VsZWN0ZWQoKTogVCB8IG51bGw7XG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlOiBUIHwgbnVsbCk7XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRzO1xuICAgIGdldCBzZWxlY3RlZHMoKTogVFtdO1xuICAgIHNldCBzZWxlY3RlZHModmFsdWVzOiBUW10pO1xuICAgIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gICAgZ2V0IG1pbkRhdGVUaW1lKCk6IFQgfCBudWxsO1xuICAgIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gICAgZ2V0IG1heERhdGVUaW1lKCk6IFQgfCBudWxsO1xuICAgIGdldCBkYXRlVGltZUZpbHRlcigpOiAoZGF0ZTogVCB8IG51bGwpID0+IGJvb2xlYW47XG4gICAgZ2V0IHNlbGVjdE1vZGUoKTogU2VsZWN0TW9kZTtcbiAgICBnZXQgaXNJblNpbmdsZU1vZGUoKTogYm9vbGVhbjtcbiAgICBnZXQgaXNJblJhbmdlTW9kZSgpOiBib29sZWFuO1xuICAgIHByaXZhdGUgZGVmYXVsdFNjcm9sbFN0cmF0ZWd5O1xuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXk6IE92ZXJsYXksIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsIGRpYWxvZ1NlcnZpY2U6IE93bERpYWxvZ1NlcnZpY2UsIG5nWm9uZTogTmdab25lLCBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGRhdGVUaW1lQWRhcHRlcjogRGF0ZVRpbWVBZGFwdGVyPFQ+LCBkZWZhdWx0U2Nyb2xsU3RyYXRlZ3k6IGFueSwgZGF0ZVRpbWVGb3JtYXRzOiBPd2xEYXRlVGltZUZvcm1hdHMsIGRvY3VtZW50OiBhbnkpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICByZWdpc3RlcklucHV0KGlucHV0OiBPd2xEYXRlVGltZUlucHV0RGlyZWN0aXZlPFQ+KTogdm9pZDtcbiAgICBvcGVuKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gZGF0ZVxuICAgICAqL1xuICAgIHNlbGVjdChkYXRlOiBUW10gfCBUKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB0aGUgc2VsZWN0ZWQgeWVhciBpbiBtdWx0aS15ZWFyIHZpZXdcbiAgICAgKiAqL1xuICAgIHNlbGVjdFllYXIobm9ybWFsaXplZFllYXI6IFQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHNlbGVjdGVkIG1vbnRoIGluIHllYXIgdmlld1xuICAgICAqICovXG4gICAgc2VsZWN0TW9udGgobm9ybWFsaXplZE1vbnRoOiBUKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwaWNrZXJcbiAgICAgKi9cbiAgICBjbG9zZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAgICovXG4gICAgY29uZmlybVNlbGVjdChldmVudD86IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgcGlja2VyIGFzIGEgZGlhbG9nXG4gICAgICovXG4gICAgcHJpdmF0ZSBvcGVuQXNEaWFsb2c7XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgcGlja2VyIGFzIHBvcHVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBvcGVuQXNQb3B1cDtcbiAgICBwcml2YXRlIGNyZWF0ZVBvcHVwO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgcG9wdXAgUG9zaXRpb25TdHJhdGVneS5cbiAgICAgKiAqL1xuICAgIHByaXZhdGUgY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5O1xufVxuIl19