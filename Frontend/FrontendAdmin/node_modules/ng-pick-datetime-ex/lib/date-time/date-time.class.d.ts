/**
 * date-time.class
 */
import { EventEmitter } from '@angular/core';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { OwlDateTimeFormats } from './adapter/date-time-format.class';
import * as ɵngcc0 from '@angular/core';
export declare type PickerType = 'both' | 'calendar' | 'timer';
export declare type PickerMode = 'popup' | 'dialog' | 'inline';
export declare type SelectMode = 'single' | 'range' | 'rangeFrom' | 'rangeTo';
export declare abstract class OwlDateTime<T> {
    protected dateTimeAdapter: DateTimeAdapter<T>;
    protected dateTimeFormats: OwlDateTimeFormats;
    /**
     * Whether to show the second's timer
     */
    private _showSecondsTimer;
    get showSecondsTimer(): boolean;
    set showSecondsTimer(val: boolean);
    /**
     * Whether the timer is in hour12 format
     */
    private _hour12Timer;
    get hour12Timer(): boolean;
    set hour12Timer(val: boolean);
    /**
     * The view that the calendar should start in.
     */
    startView: 'month' | 'year' | 'multi-years';
    /**
     * Hours to change per step
     */
    private _stepHour;
    get stepHour(): number;
    set stepHour(val: number);
    /**
     * Minutes to change per step
     */
    private _stepMinute;
    get stepMinute(): number;
    set stepMinute(val: number);
    /**
     * Seconds to change per step
     */
    private _stepSecond;
    get stepSecond(): number;
    set stepSecond(val: number);
    /**
     * Set the first day of week
     */
    private _firstDayOfWeek;
    get firstDayOfWeek(): number;
    set firstDayOfWeek(value: number);
    /**
     * Whether to hide dates in other months at the start or end of the current month.
     */
    private _hideOtherMonths;
    get hideOtherMonths(): boolean;
    set hideOtherMonths(val: boolean);
    private _id;
    get id(): string;
    abstract get selected(): T | null;
    abstract get selecteds(): T[] | null;
    abstract get dateTimeFilter(): (date: T | null) => boolean;
    abstract get maxDateTime(): T | null;
    abstract get minDateTime(): T | null;
    abstract get selectMode(): SelectMode;
    abstract get startAt(): T | null;
    abstract get opened(): boolean;
    abstract get pickerMode(): PickerMode;
    abstract get pickerType(): PickerType;
    abstract get isInSingleMode(): boolean;
    abstract get isInRangeMode(): boolean;
    abstract select(date: T | T[]): void;
    abstract yearSelected: EventEmitter<T>;
    abstract monthSelected: EventEmitter<T>;
    abstract selectYear(normalizedYear: T): void;
    abstract selectMonth(normalizedMonth: T): void;
    get formatString(): string;
    /**
     * Date Time Checker to check if the give dateTime is selectable
     */
    dateTimeChecker: (dateTime: T) => boolean;
    get disabled(): boolean;
    constructor(dateTimeAdapter: DateTimeAdapter<T>, dateTimeFormats: OwlDateTimeFormats);
    protected getValidDate(obj: any): T | null;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OwlDateTime<any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<OwlDateTime<any>, never, never, {
    "startView": "startView";
    "showSecondsTimer": "showSecondsTimer";
    "hour12Timer": "hour12Timer";
    "stepHour": "stepHour";
    "stepMinute": "stepMinute";
    "stepSecond": "stepSecond";
    "firstDayOfWeek": "firstDayOfWeek";
    "hideOtherMonths": "hideOtherMonths";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLmNsYXNzLmQudHMiLCJzb3VyY2VzIjpbImRhdGUtdGltZS5jbGFzcy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStFQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGF0ZS10aW1lLmNsYXNzXG4gKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1hZGFwdGVyLmNsYXNzJztcbmltcG9ydCB7IE93bERhdGVUaW1lRm9ybWF0cyB9IGZyb20gJy4vYWRhcHRlci9kYXRlLXRpbWUtZm9ybWF0LmNsYXNzJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgUGlja2VyVHlwZSA9ICdib3RoJyB8ICdjYWxlbmRhcicgfCAndGltZXInO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBQaWNrZXJNb2RlID0gJ3BvcHVwJyB8ICdkaWFsb2cnIHwgJ2lubGluZSc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFNlbGVjdE1vZGUgPSAnc2luZ2xlJyB8ICdyYW5nZScgfCAncmFuZ2VGcm9tJyB8ICdyYW5nZVRvJztcbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIE93bERhdGVUaW1lPFQ+IHtcbiAgICBwcm90ZWN0ZWQgZGF0ZVRpbWVBZGFwdGVyOiBEYXRlVGltZUFkYXB0ZXI8VD47XG4gICAgcHJvdGVjdGVkIGRhdGVUaW1lRm9ybWF0czogT3dsRGF0ZVRpbWVGb3JtYXRzO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgc2Vjb25kJ3MgdGltZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zaG93U2Vjb25kc1RpbWVyO1xuICAgIGdldCBzaG93U2Vjb25kc1RpbWVyKCk6IGJvb2xlYW47XG4gICAgc2V0IHNob3dTZWNvbmRzVGltZXIodmFsOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0aW1lciBpcyBpbiBob3VyMTIgZm9ybWF0XG4gICAgICovXG4gICAgcHJpdmF0ZSBfaG91cjEyVGltZXI7XG4gICAgZ2V0IGhvdXIxMlRpbWVyKCk6IGJvb2xlYW47XG4gICAgc2V0IGhvdXIxMlRpbWVyKHZhbDogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogVGhlIHZpZXcgdGhhdCB0aGUgY2FsZW5kYXIgc2hvdWxkIHN0YXJ0IGluLlxuICAgICAqL1xuICAgIHN0YXJ0VmlldzogJ21vbnRoJyB8ICd5ZWFyJyB8ICdtdWx0aS15ZWFycyc7XG4gICAgLyoqXG4gICAgICogSG91cnMgdG8gY2hhbmdlIHBlciBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcEhvdXI7XG4gICAgZ2V0IHN0ZXBIb3VyKCk6IG51bWJlcjtcbiAgICBzZXQgc3RlcEhvdXIodmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIE1pbnV0ZXMgdG8gY2hhbmdlIHBlciBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcE1pbnV0ZTtcbiAgICBnZXQgc3RlcE1pbnV0ZSgpOiBudW1iZXI7XG4gICAgc2V0IHN0ZXBNaW51dGUodmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFNlY29uZHMgdG8gY2hhbmdlIHBlciBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcFNlY29uZDtcbiAgICBnZXQgc3RlcFNlY29uZCgpOiBudW1iZXI7XG4gICAgc2V0IHN0ZXBTZWNvbmQodmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlyc3QgZGF5IG9mIHdlZWtcbiAgICAgKi9cbiAgICBwcml2YXRlIF9maXJzdERheU9mV2VlaztcbiAgICBnZXQgZmlyc3REYXlPZldlZWsoKTogbnVtYmVyO1xuICAgIHNldCBmaXJzdERheU9mV2Vlayh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGhpZGUgZGF0ZXMgaW4gb3RoZXIgbW9udGhzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGN1cnJlbnQgbW9udGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBfaGlkZU90aGVyTW9udGhzO1xuICAgIGdldCBoaWRlT3RoZXJNb250aHMoKTogYm9vbGVhbjtcbiAgICBzZXQgaGlkZU90aGVyTW9udGhzKHZhbDogYm9vbGVhbik7XG4gICAgcHJpdmF0ZSBfaWQ7XG4gICAgZ2V0IGlkKCk6IHN0cmluZztcbiAgICBhYnN0cmFjdCBnZXQgc2VsZWN0ZWQoKTogVCB8IG51bGw7XG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkcygpOiBUW10gfCBudWxsO1xuICAgIGFic3RyYWN0IGdldCBkYXRlVGltZUZpbHRlcigpOiAoZGF0ZTogVCB8IG51bGwpID0+IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgZ2V0IG1heERhdGVUaW1lKCk6IFQgfCBudWxsO1xuICAgIGFic3RyYWN0IGdldCBtaW5EYXRlVGltZSgpOiBUIHwgbnVsbDtcbiAgICBhYnN0cmFjdCBnZXQgc2VsZWN0TW9kZSgpOiBTZWxlY3RNb2RlO1xuICAgIGFic3RyYWN0IGdldCBzdGFydEF0KCk6IFQgfCBudWxsO1xuICAgIGFic3RyYWN0IGdldCBvcGVuZWQoKTogYm9vbGVhbjtcbiAgICBhYnN0cmFjdCBnZXQgcGlja2VyTW9kZSgpOiBQaWNrZXJNb2RlO1xuICAgIGFic3RyYWN0IGdldCBwaWNrZXJUeXBlKCk6IFBpY2tlclR5cGU7XG4gICAgYWJzdHJhY3QgZ2V0IGlzSW5TaW5nbGVNb2RlKCk6IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgZ2V0IGlzSW5SYW5nZU1vZGUoKTogYm9vbGVhbjtcbiAgICBhYnN0cmFjdCBzZWxlY3QoZGF0ZTogVCB8IFRbXSk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgeWVhclNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8VD47XG4gICAgYWJzdHJhY3QgbW9udGhTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFQ+O1xuICAgIGFic3RyYWN0IHNlbGVjdFllYXIobm9ybWFsaXplZFllYXI6IFQpOiB2b2lkO1xuICAgIGFic3RyYWN0IHNlbGVjdE1vbnRoKG5vcm1hbGl6ZWRNb250aDogVCk6IHZvaWQ7XG4gICAgZ2V0IGZvcm1hdFN0cmluZygpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGF0ZSBUaW1lIENoZWNrZXIgdG8gY2hlY2sgaWYgdGhlIGdpdmUgZGF0ZVRpbWUgaXMgc2VsZWN0YWJsZVxuICAgICAqL1xuICAgIGRhdGVUaW1lQ2hlY2tlcjogKGRhdGVUaW1lOiBUKSA9PiBib29sZWFuO1xuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGRhdGVUaW1lQWRhcHRlcjogRGF0ZVRpbWVBZGFwdGVyPFQ+LCBkYXRlVGltZUZvcm1hdHM6IE93bERhdGVUaW1lRm9ybWF0cyk7XG4gICAgcHJvdGVjdGVkIGdldFZhbGlkRGF0ZShvYmo6IGFueSk6IFQgfCBudWxsO1xufVxuIl19